#!/bin/bash
# Bjarne - Autonomous AI development system
#
# Commands:
#   bjarne init <idea.md>     - Bootstrap project from idea file (new or existing)
#   bjarne refresh <notes.md> - Add tasks from freeform notes (bugs, features, tweaks)
#   bjarne [n]                - Run n iterations (default 25)
#
# Loop: PLAN â†’ EXECUTE â†’ REVIEW â†’ FIX
#
# idea.md/notes.md are freeform - write whatever you want. Bjarne will figure it out.

set -e

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
RED='\033[0;31m'
CYAN='\033[0;36m'
NC='\033[0m'

# Files
TASK_FILE="TASKS.md"
CONTEXT_FILE="CONTEXT.md"
SPECS_DIR="specs"
TASK_STATE=".task"

#==============================================================================
# INIT COMMAND - Bootstrap from idea file (works on new or existing projects)
#==============================================================================
if [[ "$1" == "init" ]]; then
    IDEA_FILE="$2"

    if [[ -z "$IDEA_FILE" ]]; then
        echo -e "${RED}Usage: bjarne init <idea.md>${NC}"
        exit 1
    fi

    if [[ ! -f "$IDEA_FILE" ]]; then
        echo -e "${RED}Error: $IDEA_FILE not found${NC}"
        exit 1
    fi

    # Detect if this is an existing project (has source code files)
    EXISTING_PROJECT="false"
    SRC_FILES=$(find . -maxdepth 3 -type f \( -name "*.js" -o -name "*.ts" -o -name "*.py" -o -name "*.php" -o -name "*.go" -o -name "*.rs" -o -name "*.java" -o -name "*.tsx" -o -name "*.jsx" \) 2>/dev/null | grep -v node_modules | grep -v vendor | grep -v __pycache__ | head -20)
    [[ -n "$SRC_FILES" ]] && EXISTING_PROJECT="true"

    if [[ "$EXISTING_PROJECT" == "true" ]]; then
        echo -e "${CYAN}Bjarne initializing EXISTING project from: $IDEA_FILE${NC}"
    else
        echo -e "${CYAN}Bjarne initializing NEW project from: $IDEA_FILE${NC}"
    fi

    # Detect existing environment
    DETECTED=""
    [[ -f "package.json" ]] && DETECTED="${DETECTED}Found: package.json (Node.js/JavaScript)\n"
    [[ -f "tsconfig.json" ]] && DETECTED="${DETECTED}Found: tsconfig.json (TypeScript)\n"
    [[ -f "composer.json" ]] && DETECTED="${DETECTED}Found: composer.json (PHP)\n"
    [[ -f "requirements.txt" ]] && DETECTED="${DETECTED}Found: requirements.txt (Python)\n"
    [[ -f "pyproject.toml" ]] && DETECTED="${DETECTED}Found: pyproject.toml (Python)\n"
    [[ -f "pubspec.yaml" ]] && DETECTED="${DETECTED}Found: pubspec.yaml (Flutter/Dart)\n"
    [[ -f "Cargo.toml" ]] && DETECTED="${DETECTED}Found: Cargo.toml (Rust)\n"
    [[ -f "go.mod" ]] && DETECTED="${DETECTED}Found: go.mod (Go)\n"
    [[ -f "CLAUDE.md" ]] && DETECTED="${DETECTED}Found: CLAUDE.md (existing project rules)\n"
    [[ -f ".env.example" ]] && DETECTED="${DETECTED}Found: .env.example (needs .env setup)\n"
    [[ -d "node_modules" ]] || [[ -f "package.json" ]] && [[ ! -d "node_modules" ]] && DETECTED="${DETECTED}Note: node_modules missing - needs npm install\n"
    [[ -d "vendor" ]] || [[ -f "composer.json" ]] && [[ ! -d "vendor" ]] && DETECTED="${DETECTED}Note: vendor missing - needs composer install\n"

    # For existing projects, include source file list
    EXISTING_CODE_INFO=""
    if [[ "$EXISTING_PROJECT" == "true" ]]; then
        EXISTING_CODE_INFO="
## EXISTING SOURCE FILES (explore these to understand what's built):
$SRC_FILES

This is an EXISTING project. You MUST:
1. Explore and understand the existing codebase structure
2. Read key files to understand what's already implemented
3. Document existing functionality in CONTEXT.md
4. Create tasks that BUILD ON existing code, not duplicate it
"
    fi

    read -r -d '' INIT_PROMPT << 'INIT_EOF' || true
# PROJECT INITIALIZATION

You have an idea file (freeform, any format) and detected environment info.
Your job: Create project structure that SUPPORTS the user's vision.

## Core Principle: RESPECT THE IDEA
- User's idea is the source of truth - don't change their concept
- If they specified something, use it exactly
- If they didn't specify, infer sensibly from context
- Fill gaps to make it buildable, but preserve their intent
- A detailed spec needs less inference; a vague idea needs more

## Phase 1: Understand
1. Read the idea file - extract what the user actually wants
2. Identify what's SPECIFIED (use as-is) vs what's UNSPECIFIED (infer)
3. Check detected environment for existing tech stack
4. If CLAUDE.md exists, read for existing project rules
5. **IF EXISTING PROJECT**: Explore the codebase! Read source files to understand:
   - What's already built
   - Code patterns and architecture used
   - What the idea is asking to ADD or CHANGE vs what exists

## Phase 2: Infer Missing Pieces (only if not specified)
For anything the user didn't specify, make smart choices:
- Tech stack: Use detected, or pick appropriate for project type
- Testing: Default to basic tests unless user says otherwise
- Architecture: Simple and appropriate for scope (or follow existing patterns)
- Scope: Take idea at face value - don't expand or reduce

## Phase 3: Create Files

### 1. CONTEXT.md (static reference for development)
```markdown
# [Project Name from idea]

## What We're Building
[User's vision - preserve their words/intent]

## Existing Codebase (if applicable)
[Summary of what already exists - key files, patterns, architecture]

## Tech Stack
[Detected or inferred]

## Commands
- Build: [detected or standard]
- Test: [detected or standard]
- Run: [detected or standard]

## Key Decisions
[Only if user specified preferences, constraints, or requirements]

## References
- specs/ for detailed specifications
```

### 2. TASKS.md
Break the idea into atomic tasks:
- Setup tasks first (if node_modules/vendor/.env missing)
- **For existing projects**: Tasks should reference existing code to modify/extend
- Then features from the idea (in logical order)
- Each task completable in one iteration
- Format: `- [ ] Task description`
- Number of tasks should match project scope (don't pad)

### 3. specs/ folder (only if needed)
Create specs that ADD VALUE - don't create empty scaffolds:
- API project with endpoints â†’ specs/API.md with routes, payloads
- UI with specific design â†’ specs/DESIGN_SYSTEM.md
- Complex data model â†’ specs/DATA_MODEL.md
- Skip specs that would just repeat the idea

## What NOT to Do
- Don't add features the user didn't ask for
- Don't create specs that just restate obvious things
- Don't expand scope beyond what they described
- Don't change their architectural choices if specified
- Don't add "nice to have" tasks - stick to the idea
- **For existing projects**: Don't recreate what already exists!

Read the idea, understand the vision, build the support structure.
INIT_EOF

    IDEA_CONTENT=$(cat "$IDEA_FILE")

    # Read CLAUDE.md if exists
    CLAUDE_MD=""
    if [[ -f "CLAUDE.md" ]]; then
        CLAUDE_MD="

## Existing CLAUDE.md (project rules to respect):
$(cat CLAUDE.md)
"
    fi

    claude -p --dangerously-skip-permissions "# IDEA FILE CONTENT:

$IDEA_CONTENT

---

## DETECTED ENVIRONMENT:
$DETECTED
$EXISTING_CODE_INFO
$CLAUDE_MD
---

$INIT_PROMPT"

    # Verify files were created
    if [[ -f "$CONTEXT_FILE" ]] && [[ -f "$TASK_FILE" ]]; then
        echo -e "${GREEN}Project initialized!${NC}"
        echo -e "  - $CONTEXT_FILE"
        echo -e "  - $TASK_FILE"
        [[ -d "$SPECS_DIR" ]] && echo -e "  - $SPECS_DIR/"

        # Init git repo if git available and not already in a repo
        if command -v git &> /dev/null; then
            if ! git rev-parse --git-dir &> /dev/null 2>&1; then
                git init -q && \
                git add -A && \
                git commit -q -m "Initial project setup by Bjarne" && \
                echo -e "  - git repo initialized" || true
            fi
        fi

        echo ""
        echo -e "${CYAN}Run 'bjarne' to start development${NC}"
    else
        echo -e "${RED}Initialization incomplete - check output above${NC}"
    fi

    exit 0
fi

#==============================================================================
# REFRESH COMMAND - Add tasks from freeform notes
#==============================================================================
if [[ "$1" == "refresh" ]]; then
    NOTES_FILE="$2"

    if [[ -z "$NOTES_FILE" ]]; then
        echo -e "${RED}Usage: bjarne refresh <notes.md>${NC}"
        exit 1
    fi

    if [[ ! -f "$NOTES_FILE" ]]; then
        echo -e "${RED}Error: $NOTES_FILE not found${NC}"
        exit 1
    fi

    if [[ ! -f "$CONTEXT_FILE" ]]; then
        echo -e "${RED}Error: $CONTEXT_FILE not found - run 'bjarne init' first${NC}"
        exit 1
    fi

    if [[ ! -f "$TASK_FILE" ]]; then
        echo -e "${RED}Error: $TASK_FILE not found - run 'bjarne init' first${NC}"
        exit 1
    fi

    echo -e "${CYAN}Bjarne refreshing project from: $NOTES_FILE${NC}"

    read -r -d '' REFRESH_PROMPT << 'REFRESH_EOF' || true
# PROJECT REFRESH

You have freeform notes from the user after testing/reviewing the project.
Your job: Update CONTEXT.md if needed and ADD new tasks to TASKS.md.

## The Notes May Contain
- Bug reports from manual testing
- New feature requests
- Tweaks and adjustments needed
- Things that didn't work as expected
- New ideas to add

## Your Job
1. Read the notes file carefully
2. Read current CONTEXT.md to understand the project
3. Read current TASKS.md to see what's done and what's pending
4. Explore relevant code if needed to understand the issues

## What to Update

### CONTEXT.md (only if needed)
- Add new architectural decisions if the notes change direction
- Update "What We're Building" only if scope genuinely changed
- Usually you WON'T need to change CONTEXT.md

### TASKS.md (main update)
- KEEP all existing tasks (completed and pending)
- ADD new tasks at the bottom based on the notes
- Group related new tasks together
- Each task should be atomic (one iteration)
- Format: `- [ ] Task description`

## Task Naming
- Bug fix: `- [ ] Fix: [description of bug]`
- New feature: `- [ ] Add: [feature description]`
- Tweak/adjust: `- [ ] Adjust: [what to change]`
- Refactor: `- [ ] Refactor: [what to improve]`

## What NOT to Do
- Don't remove or reorder existing tasks
- Don't mark tasks complete (that's for the dev loop)
- Don't expand beyond what's in the notes
- Don't duplicate existing tasks

Read the notes, understand what's needed, update the project.
REFRESH_EOF

    NOTES_CONTENT=$(cat "$NOTES_FILE")
    CONTEXT_CONTENT=$(cat "$CONTEXT_FILE")
    TASKS_CONTENT=$(cat "$TASK_FILE")

    # Read CLAUDE.md if exists
    CLAUDE_MD=""
    if [[ -f "CLAUDE.md" ]]; then
        CLAUDE_MD="
## Project Rules (from CLAUDE.md):
$(cat CLAUDE.md)
"
    fi

    claude -p --dangerously-skip-permissions "# USER'S NOTES:

$NOTES_CONTENT

---

## CURRENT CONTEXT.md:
$CONTEXT_CONTENT

---

## CURRENT TASKS.md:
$TASKS_CONTENT

$CLAUDE_MD
---

$REFRESH_PROMPT"

    # Show result
    NEW_TASKS=$(grep -c '^\s*- \[ \]' "$TASK_FILE" 2>/dev/null || echo "0")
    echo -e "${GREEN}Project refreshed!${NC}"
    echo -e "  - $NEW_TASKS pending tasks in $TASK_FILE"
    echo ""
    echo -e "${CYAN}Run 'bjarne' to work through the new tasks${NC}"

    exit 0
fi

#==============================================================================
# MAIN LOOP - PLAN â†’ EXECUTE â†’ REVIEW â†’ FIX
#==============================================================================

MAX_ITERATIONS=${1:-25}

# Prompts
read -r -d '' PLAN_PROMPT << 'PLAN_EOF' || true
# PLAN STEP

You are planning ONE task from TASKS.md.

## Your Job
1. Read CONTEXT.md for project info and commands
2. Read TASKS.md - find the FIRST unchecked `- [ ]` task
3. Read specs/ folder for detailed specifications
4. Search the codebase for existing patterns, utilities, components
5. Write a plan to .task file

## Write to .task file:
```
TASK: [exact task text from TASKS.md]

EXISTING_CODE:
- [file/function to reuse]

PATTERNS:
- [pattern from codebase to follow]

PLAN:
1. [specific step]
2. [specific step]

FILES_TO_CREATE: [list]
FILES_TO_MODIFY: [list]
TEST_COMMAND: [from CONTEXT.md or detected]
```

## Architecture Principles
- REUSE existing code - search first
- EXTEND existing files when logical
- ONE clear responsibility per file
- Follow existing patterns in codebase
- Match existing code style

DO NOT implement. Just plan.
PLAN_EOF

read -r -d '' EXECUTE_PROMPT << 'EXEC_EOF' || true
# EXECUTE STEP

Read .task file. Follow the plan exactly.

## Rules
- Follow the PLAN steps in order
- REUSE code listed in EXISTING_CODE
- Follow PATTERNS for consistency
- Match existing code style in the project
- Clear names, no abbreviations
- Handle errors meaningfully

## Code Quality (adapt to project's tech stack)
- Keep functions focused (single responsibility)
- Keep files cohesive (related code together)
- Comments explain WHY not WHAT

## When Done
Mark the task complete in TASKS.md with a short note if you learned something useful:
- Simple completion: `- [x] Task description`
- With note: `- [x] Task description â†’ Note: [one-line insight]`

Only add a note if it would help future tasks (e.g., "used X instead of Y", "requires Z first").

Then commit: "feat: [task description]"
EXEC_EOF

read -r -d '' REVIEW_PROMPT << 'REVIEW_EOF' || true
# REVIEW STEP

Review implementation against .task plan.

## Check Plan Compliance
- Was EXISTING_CODE reused?
- Were PATTERNS followed?
- All PLAN steps done?

## Auto-Detect Focus Areas
Based on what was implemented, check relevant areas:

**If touched auth/passwords/tokens/API keys:**
- Input validation and sanitization
- No hardcoded secrets
- Secure token handling

**If touched database/SQL:**
- Prepared statements (no SQL injection)
- Proper error handling

**If touched user input/forms:**
- Input validation
- XSS prevention (escape output)

**If touched API endpoints:**
- Proper response format
- Error responses
- Authentication checks

**If touched async/state:**
- Race condition checks
- Error state handling

**If touched UI:**
- Matches design system (if specs/DESIGN_SYSTEM.md exists)
- Accessibility basics

## Run Checks
Use TEST_COMMAND from .task file (or detect from CONTEXT.md)

## Classify Issues by Severity
- ðŸ”´ BLOCKER: Security vulnerabilities, data loss risk, crashes
- ðŸŸ¡ ISSUE: Bugs, logic errors, missing error handling
- ðŸŸ¢ SUGGESTION: Style improvements, minor optimizations

## Check Against Pending Tasks
Before flagging unused code, check TASKS.md:
- Will a pending task use it? â†’ Not an issue, note "scaffolding for task X"
- No pending task needs it? â†’ Flag as ISSUE: remove dead code

Don't suppress warnings for scaffolding. Don't keep actual dead code.

## Append to .task:
```
REVIEW_RESULT:
BUILD_PASSED: yes/no
TESTS_PASSED: yes/no

BLOCKERS:
- [if any]

ISSUES:
- [if any]

SUGGESTIONS:
- [if any, brief]
```

If no issues found, just write:
```
REVIEW_RESULT:
BUILD_PASSED: yes
TESTS_PASSED: yes
ISSUES: none
```
REVIEW_EOF

read -r -d '' FIX_PROMPT << 'FIX_EOF' || true
# FIX STEP

Read REVIEW_RESULT in .task file. Fix issues by priority.

## Priority Order
1. ðŸ”´ BLOCKERS first - these must be fixed
2. ðŸŸ¡ ISSUES second - fix if straightforward
3. ðŸŸ¢ SUGGESTIONS - fix only if trivial

## Your Job
1. Fix BLOCKERS (mandatory)
2. Fix ISSUES (should fix)
3. Consider SUGGESTIONS (nice to have)
4. Re-run TEST_COMMAND to confirm
5. Commit fixes: "fix: [description]"

## After Fixing
If all fixed + tests pass:
- Delete .task file
- Ensure task is marked `- [x]` in TASKS.md (with note if useful)

If cannot fix (blocked):
- Unmark task in TASKS.md back to `- [ ]`
- Add blocker note: `- [ ] Task description âš ï¸ Blocked: [reason]`
- Keep .task file for context
FIX_EOF

# Check required files
if [[ ! -f "$TASK_FILE" ]]; then
    echo -e "${RED}Error: $TASK_FILE not found${NC}"
    echo -e "Run 'bjarne init <idea.md>' first"
    exit 1
fi

if [[ ! -f "$CONTEXT_FILE" ]]; then
    echo -e "${YELLOW}Warning: $CONTEXT_FILE not found${NC}"
fi

# Load context fresh each iteration
load_context() {
    CONTEXT=""
    if [[ -f "$CONTEXT_FILE" ]]; then
        CONTEXT=$(cat "$CONTEXT_FILE")
    fi
    # Also include CLAUDE.md if exists (project rules)
    if [[ -f "CLAUDE.md" ]]; then
        CONTEXT="$CONTEXT

## Project Rules (from CLAUDE.md):
$(cat CLAUDE.md)"
    fi
}

echo -e "${CYAN}Bjarne starting - max $MAX_ITERATIONS iterations${NC}"
echo -e "${CYAN}Loop: PLAN â†’ EXECUTE â†’ REVIEW â†’ FIX${NC}"
echo ""

for i in $(seq 1 $MAX_ITERATIONS); do
    # Load context fresh each iteration
    load_context

    # Check for remaining tasks
    if ! grep -q '^\s*- \[ \]' "$TASK_FILE"; then
        echo -e "${GREEN}All tasks complete!${NC}"
        rm -f "$TASK_STATE"
        exit 0
    fi

    REMAINING=$(grep -c '^\s*- \[ \]' "$TASK_FILE" || echo "0")
    echo -e "${YELLOW}=== Iteration $i/$MAX_ITERATIONS ($REMAINING tasks remaining) ===${NC}"

    # PLAN
    echo -e "${BLUE}[1/4 PLAN]${NC} Analyzing..."
    claude -p --dangerously-skip-permissions "$CONTEXT

$PLAN_PROMPT"

    if [[ ! -f "$TASK_STATE" ]]; then
        echo -e "${RED}Plan failed - no .task file${NC}"
        continue
    fi

    # EXECUTE
    echo -e "${BLUE}[2/4 EXECUTE]${NC} Implementing..."
    claude -p --dangerously-skip-permissions "$CONTEXT

$EXECUTE_PROMPT"

    # REVIEW
    echo -e "${BLUE}[3/4 REVIEW]${NC} Reviewing..."
    claude -p --dangerously-skip-permissions "$CONTEXT

$REVIEW_PROMPT"

    # FIX
    echo -e "${BLUE}[4/4 FIX]${NC} Fixing..."
    claude -p --dangerously-skip-permissions "$CONTEXT

$FIX_PROMPT"

    sleep 2
done

echo -e "${YELLOW}Max iterations reached${NC}"
