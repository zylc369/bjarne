#!/bin/bash
# Bjarne - Autonomous AI development system
#
# Commands:
#   bjarne init [--safe] <idea.md>  - Bootstrap project from idea file
#   bjarne refresh <notes.md>       - Add tasks from freeform notes
#   bjarne task [opts] "desc"       - Run isolated single-task mode
#   bjarne [n]                      - Run n iterations (default 25)
#   bjarne --rebuild                - Force rebuild Docker image (safe mode only)
#
# Task mode options:
#   --safe              - Run in Docker container
#   -f, --file <file>   - Read task description from file
#   --branch <name>     - Use custom branch name
#   --no-pr             - Skip PR creation
#   -n <num>            - Max iterations (default 25)
#
# Safe mode (--safe): Runs Claude in a Docker container that can only access
# the project directory. Use for unattended runs to prevent accidental
# damage to other files on the system.
#
# Loop: PLAN â†’ EXECUTE â†’ REVIEW â†’ FIX
#
# Task mode: Isolated single-task fixes. Does NOT touch CONTEXT.md, TASKS.md.
# Uses .bjarne/tasks/<task-id>/ for state. Auto-creates branch and PR if git/gh available.
#
# idea.md/notes.md are freeform - write whatever you want. Bjarne will figure it out.

set -e

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
RED='\033[0;31m'
CYAN='\033[0;36m'
NC='\033[0m'

# Files
TASK_FILE="TASKS.md"
CONTEXT_FILE="CONTEXT.md"
SPECS_DIR="specs"
TASK_STATE=".task"

# Retry settings
MAX_RETRIES=5
RETRY_DELAY=10

# Logging
LOG_DIR=".bjarne/logs"
LOG_FILE="$LOG_DIR/bjarne.log"

# Ensure log directory exists
mkdir -p "$LOG_DIR"

# Log function
log() {
    local level="$1"
    local msg="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] [$level] $msg" >> "$LOG_FILE"
}

# Log with context (for failures)
log_failure() {
    local phase="$1"
    local attempt="$2"
    local exit_code="$3"
    local output="$4"
    local prompt_size="$5"
    local prompt="$6"

    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local fail_file="$LOG_DIR/failure_${timestamp//[: -]/_}.log"

    {
        echo "=== BJARNE FAILURE LOG ==="
        echo "Timestamp: $timestamp"
        echo "Phase: $phase"
        echo "Attempt: $attempt/$MAX_RETRIES"
        echo "Exit code: $exit_code"
        echo "Prompt size: $prompt_size bytes"
        echo "Working directory: $(pwd)"
        echo "Safe mode: $SAFE_MODE"
        echo ""
        echo "=== CLAUDE OUTPUT ==="
        echo "$output"
        echo ""
        echo "=== ACTUAL PROMPT SENT ==="
        echo "$prompt"
        echo ""
        echo "=== CURRENT .task FILE (if exists) ==="
        if [[ -f "$TASK_STATE" ]]; then
            cat "$TASK_STATE"
        else
            echo "(no .task file)"
        fi
    } > "$fail_file"

    log "ERROR" "Failure logged to $fail_file"
    echo -e "${YELLOW}  Failure details saved to: $fail_file${NC}"
}

# Safe mode (Docker) settings
BJARNE_DIR=".bjarne"
DOCKERFILE="$BJARNE_DIR/Dockerfile"
SAFE_MODE=false
IMAGE_NAME=""

#==============================================================================
# PROMPTS - Defined early so both task mode and main loop can use them
#==============================================================================

read -r -d '' PLAN_PROMPT << 'PLAN_EOF' || true
# PLAN STEP

You are planning ONE task from TASKS.md.

## Your Job
1. Read CONTEXT.md for project info and commands
2. Read TASKS.md - find the FIRST unchecked `- [ ]` task
3. **Parse the task**: Extract ACTION and OUTCOME (format: `Action â†’ Outcome`)
4. Read specs/ folder for detailed specifications
5. Search the codebase for existing patterns, utilities, components
6. Write a plan to .task file

## Write to .task file:
```
TASK: [exact task text from TASKS.md]
ACTION: [what to implement]
EXPECTED_OUTCOME: [how to verify success - from the â†’ part]

EXISTING_CODE:
- [file/function to reuse]

PATTERNS:
- [pattern from codebase to follow]

PLAN:
1. [specific step]
2. [specific step]

FILES_TO_CREATE: [list]
FILES_TO_MODIFY: [list]
TEST_COMMAND: [from CONTEXT.md or detected]

OUTCOME_VERIFICATION:
- [specific check to confirm outcome, e.g., "grep for button with href=/login"]
- [curl command, file check, or code inspection to verify]
```

## Architecture Principles
- REUSE existing code - search first
- EXTEND existing files when logical
- ONE clear responsibility per file
- Follow existing patterns in codebase
- Match existing code style

DO NOT implement. Just plan.
PLAN_EOF

read -r -d '' EXECUTE_PROMPT << 'EXEC_EOF' || true
# EXECUTE STEP

Read .task file. Follow the plan exactly.

## Rules
- Follow the PLAN steps in order
- REUSE code listed in EXISTING_CODE
- Follow PATTERNS for consistency
- Match existing code style in the project
- Clear names, no abbreviations
- Handle errors meaningfully

## Code Quality (adapt to project's tech stack)
- Keep functions focused (single responsibility)
- Keep files cohesive (related code together)
- Comments explain WHY not WHAT

## When Done
Mark the task complete in TASKS.md with a short note if you learned something useful:
- Simple completion: `- [x] Task description`
- With note: `- [x] Task description â†’ Note: [one-line insight]`

Only add a note if it would help future tasks (e.g., "used X instead of Y", "requires Z first").

Then commit: "feat: [task description]"
EXEC_EOF

read -r -d '' REVIEW_PROMPT << 'REVIEW_EOF' || true
# REVIEW STEP

Review implementation against .task plan.

## 1. VERIFY OUTCOME FIRST (Most Important!)
Read EXPECTED_OUTCOME and OUTCOME_VERIFICATION from .task file.
Actually run the verification steps to confirm the outcome was achieved:
- If it says "button exists with href=/login" â†’ grep/search for it
- If it says "API returns 200" â†’ curl the endpoint
- If it says "error message shows" â†’ check the component renders it
- If it says "file created at X" â†’ verify file exists

**If outcome NOT achieved**: This is a ðŸ”´ BLOCKER - the task isn't done.
**If outcome achieved**: Continue to code quality checks.

## 2. Check Plan Compliance
- Was EXISTING_CODE reused?
- Were PATTERNS followed?
- All PLAN steps done?

## Auto-Detect Focus Areas
Based on what was implemented, check relevant areas:

**If touched auth/passwords/tokens/API keys:**
- Input validation and sanitization
- No hardcoded secrets
- Secure token handling

**If touched database/SQL:**
- Prepared statements (no SQL injection)
- Proper error handling

**If touched user input/forms:**
- Input validation
- XSS prevention (escape output)

**If touched API endpoints:**
- Proper response format
- Error responses
- Authentication checks

**If touched async/state:**
- Race condition checks
- Error state handling

**If touched UI:**
- Matches design system (if specs/DESIGN_SYSTEM.md exists)
- Accessibility basics

## Run Checks
Use TEST_COMMAND from .task file (or detect from CONTEXT.md)

## Testing Approach
Check what testing infrastructure exists in the project:
- If tests exist â†’ run them, ensure new code is covered
- Testing expectations depend on context (see mode-specific guidance if present)

## Classify Issues by Type AND Severity

### Issue Types:
- ðŸ”§ ENVIRONMENT: Missing tools, dependencies, wrong container setup, config needed
- ðŸ’» CODE: Bugs, logic errors, security issues, missing error handling

### Severity:
- ðŸ”´ BLOCKER: Security vulnerabilities, data loss risk, crashes
- ðŸŸ¡ ISSUE: Bugs, logic errors, missing error handling
- ðŸŸ¢ SUGGESTION: Style improvements, minor optimizations

## CRITICAL: Environment Issues Are SOLVABLE, Not Blockers
If you encounter an environment issue (missing tool, dependency, wrong setup):
- This is NOT a blocker - it's a SOLVABLE ISSUE
- Examples: "Chrome not installed", "missing npm package", "Docker needs config"
- Mark as: ðŸ”§ ENVIRONMENT ISSUE (not BLOCKER)
- Include REMEDIATION: what needs to be installed/configured to fix it

## Check Against Pending Tasks
Before flagging unused code, check TASKS.md:
- Will a pending task use it? â†’ Not an issue, note "scaffolding for task X"
- No pending task needs it? â†’ Flag as ISSUE: remove dead code

Don't suppress warnings for scaffolding. Don't keep actual dead code.

## Append to .task:
```
REVIEW_RESULT:
OUTCOME_ACHIEVED: yes/no
OUTCOME_EVIDENCE: [what you checked and found]
BUILD_PASSED: yes/no
TESTS_PASSED: yes/no

ENVIRONMENT_ISSUES:
- [type] [description] â†’ REMEDIATION: [how to fix]

BLOCKERS:
- [if any - includes outcome not achieved]

ISSUES:
- [if any]

SUGGESTIONS:
- [if any, brief]
```

If all good, write:
```
REVIEW_RESULT:
OUTCOME_ACHIEVED: yes
OUTCOME_EVIDENCE: [brief proof]
BUILD_PASSED: yes
TESTS_PASSED: yes
ISSUES: none
```
REVIEW_EOF

read -r -d '' FIX_PROMPT << 'FIX_EOF' || true
# FIX STEP

Read REVIEW_RESULT in .task file. Fix issues by priority.

## Priority Order
1. âŒ OUTCOME_ACHIEVED: no - The task isn't done! Fix implementation first.
2. ðŸ”§ ENVIRONMENT_ISSUES - CREATE REMEDIATION TASKS
3. ðŸ”´ BLOCKERS - code issues that must be fixed
4. ðŸŸ¡ ISSUES - fix if straightforward
5. ðŸŸ¢ SUGGESTIONS - fix only if trivial

## If OUTCOME_ACHIEVED is "no"
The implementation doesn't do what the task required. You must:
1. Read EXPECTED_OUTCOME and OUTCOME_EVIDENCE from .task
2. Figure out WHY the outcome wasn't achieved
3. Fix the implementation until the outcome IS achieved
4. Re-verify the outcome yourself before proceeding
This is NOT optional - a task without its outcome is not done.

## Handling ENVIRONMENT_ISSUES (Critical!)
Environment issues are SOLVABLE. You must:
1. Read the REMEDIATION from .task file
2. ADD A NEW TASK to TASKS.md to fix the environment issue
   - Insert it BEFORE the current task (so it runs next iteration)
   - Format: `- [ ] Setup: [remediation action]`
   - Examples:
     - `- [ ] Setup: Install Chromium and dependencies in Dockerfile.dev`
     - `- [ ] Setup: Add missing npm package X to dependencies`
     - `- [ ] Setup: Configure Docker to support tool Y`
3. Unmark current task back to `- [ ]` (it will retry after environment is fixed)
4. Delete .task file
5. DO NOT mark as blocked - the environment task will fix it

## Your Job for Code Issues
1. Fix BLOCKERS (mandatory)
2. Fix ISSUES (should fix)
3. Consider SUGGESTIONS (nice to have)
4. Re-run TEST_COMMAND to confirm
5. Commit fixes: "fix: [description]"

## After Fixing
If all fixed + tests pass:
- Delete .task file
- Ensure task is marked `- [x]` in TASKS.md (with note if useful)

If environment issue found:
- Add remediation task to TASKS.md (see above)
- Unmark current task
- Delete .task file
- CONTINUE (not blocked!)

If TRUE code blocker (rare - only security/data issues with no fix):
- Unmark task in TASKS.md back to `- [ ]`
- Add blocker note: `- [ ] Task description âš ï¸ Blocked: [reason]`
- Keep .task file for context
FIX_EOF

#==============================================================================
# SAFE MODE FUNCTIONS
#==============================================================================

# Detect if project uses safe mode
detect_safe_mode() {
    if [[ -f "$DOCKERFILE" ]]; then
        # Check if Docker is available
        if ! command -v docker &>/dev/null; then
            echo -e "${RED}Error: Docker required for safe mode but not found${NC}"
            exit 1
        fi

        # Check if credentials exist
        if [[ ! -f "$HOME/.claude/.credentials.json" ]]; then
            echo -e "${RED}Error: Claude credentials not found at ~/.claude/.credentials.json${NC}"
            echo -e "Run 'claude' on the host first to authenticate"
            exit 1
        fi

        SAFE_MODE=true
        # Generate image name from current directory
        PROJECT_NAME=$(basename "$(pwd)" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g')
        IMAGE_NAME="bjarne-${PROJECT_NAME}"
    fi
}

# Build Docker image if needed
build_docker_image() {
    local force_rebuild="$1"

    if [[ "$force_rebuild" == "true" ]] || ! docker image inspect "$IMAGE_NAME" &>/dev/null 2>&1; then
        echo -e "${CYAN}Building Docker image: $IMAGE_NAME${NC}"
        docker build -t "$IMAGE_NAME" -f "$DOCKERFILE" . || {
            echo -e "${RED}Docker build failed${NC}"
            exit 1
        }
        echo -e "${GREEN}Image built successfully${NC}"
    else
        echo -e "${CYAN}Using cached image: $IMAGE_NAME${NC}"
    fi
}

# Get appropriate Docker base image for detected tech stack
get_base_image() {
    if [[ -f "package.json" ]]; then
        echo "node:22-bookworm"
    elif [[ -f "requirements.txt" ]] || [[ -f "pyproject.toml" ]]; then
        echo "python:3.12-bookworm"
    elif [[ -f "Cargo.toml" ]]; then
        echo "rust:1-bookworm"
    elif [[ -f "go.mod" ]]; then
        echo "golang:1.23-bookworm"
    elif [[ -f "composer.json" ]]; then
        echo "php:8.4-cli-bookworm"
    elif [[ -f "pubspec.yaml" ]]; then
        echo "dart:stable"
    else
        # Default to Node as it includes npm for Claude Code
        echo "node:22-bookworm"
    fi
}

# Get volume mount for tech-specific dependencies
get_dep_volume() {
    local project_name="$1"

    if [[ -f "package.json" ]]; then
        echo "${project_name}-node-modules:/workspace/node_modules"
    elif [[ -f "requirements.txt" ]] || [[ -f "pyproject.toml" ]]; then
        echo "${project_name}-venv:/workspace/.venv"
    elif [[ -f "Cargo.toml" ]]; then
        echo "${project_name}-target:/workspace/target"
    elif [[ -f "go.mod" ]]; then
        echo "${project_name}-gopath:/go"
    elif [[ -f "composer.json" ]]; then
        echo "${project_name}-vendor:/workspace/vendor"
    else
        echo ""
    fi
}

# Generate Dockerfile for safe mode
generate_dockerfile() {
    local base_image=$(get_base_image)

    mkdir -p "$BJARNE_DIR"

    cat > "$DOCKERFILE" << EOF
# Auto-generated by bjarne init --safe
# Modify as needed, then run: bjarne --rebuild

FROM $base_image

# Install Node.js if not present (needed for Claude Code CLI)
RUN command -v node >/dev/null 2>&1 || { \\
    apt-get update && apt-get install -y nodejs npm && rm -rf /var/lib/apt/lists/*; \\
}

# Install Claude Code CLI
RUN npm install -g @anthropic-ai/claude-code

# Install common dev tools
RUN apt-get update && apt-get install -y git curl && rm -rf /var/lib/apt/lists/*

# Create non-root user (Claude Code refuses --dangerously-skip-permissions as root)
# Make home directory world-writable so any UID can write (container is sandboxed anyway)
RUN useradd -m -s /bin/bash bjarne && \\
    mkdir -p /workspace && chown bjarne:bjarne /workspace && \\
    mkdir -p /home/bjarne/.claude && \\
    chmod -R 777 /home/bjarne
USER bjarne

WORKDIR /workspace
EOF

    echo -e "  - Generated $DOCKERFILE (base: $base_image)"
}

#==============================================================================
# GIT/GH DETECTION FUNCTIONS (for task command)
#==============================================================================

# Detect if git is available and we're in a repo
detect_git() {
    if command -v git &>/dev/null && git rev-parse --git-dir &>/dev/null 2>&1; then
        echo "1"
    else
        echo "0"
    fi
}

# Detect if gh CLI is available and authenticated
detect_gh() {
    if command -v gh &>/dev/null && gh auth status &>/dev/null 2>&1; then
        echo "1"
    else
        echo "0"
    fi
}

# Generate task ID from description
generate_task_id() {
    local description="$1"
    local timestamp=$(date +%s)
    local slug=$(echo "$description" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | cut -c1-30)
    echo "${timestamp}-${slug}"
}

# Run claude with retry logic (safe mode aware)
# Usage: run_claude "prompt" "PHASE_NAME"
run_claude() {
    local prompt="$1"
    local phase="${2:-UNKNOWN}"
    local attempt=1
    local exit_code
    local output
    local prompt_size=${#prompt}

    log "INFO" "Starting $phase phase (prompt: $prompt_size bytes)"

    while [[ $attempt -le $MAX_RETRIES ]]; do
        if [[ "$SAFE_MODE" == true ]]; then
            # Run in Docker container (as 'bjarne' user, not root)
            local docker_args="-v $(pwd):/workspace"
            docker_args+=" -v $HOME/.claude/.credentials.json:/home/bjarne/.claude/.credentials.json:ro"

            # Add gh CLI config if available (for PR creation in task mode)
            if [[ -d "$HOME/.config/gh" ]]; then
                docker_args+=" -v $HOME/.config/gh:/home/bjarne/.config/gh:ro"
            fi

            # Add gitconfig if available (for commits)
            if [[ -f "$HOME/.gitconfig" ]]; then
                docker_args+=" -v $HOME/.gitconfig:/home/bjarne/.gitconfig:ro"
            fi

            # Add dependency volume if applicable
            local dep_volume=$(get_dep_volume "$PROJECT_NAME")
            if [[ -n "$dep_volume" ]]; then
                docker_args+=" -v $dep_volume"
            fi

            # Capture both stdout and stderr
            # Run as host user's UID/GID so mounted files have correct permissions
            output=$(docker run --rm --user "$(id -u):$(id -g)" -e HOME=/home/bjarne \
                $docker_args -w /workspace "$IMAGE_NAME" \
                claude -p --dangerously-skip-permissions "$prompt" 2>&1)
            exit_code=$?
        else
            # Run on host (existing behavior), capture output
            output=$(claude -p --dangerously-skip-permissions "$prompt" 2>&1)
            exit_code=$?
        fi

        if [[ $exit_code -eq 0 ]]; then
            # Output the result (so it still shows on screen)
            echo "$output"
            log "INFO" "$phase phase completed successfully"
            return 0
        fi

        # Check for the specific streaming error
        if echo "$output" | grep -q "only prompt commands are supported in streaming mode"; then
            log "ERROR" "$phase: Got 'streaming mode' error (attempt $attempt)"
            echo -e "${YELLOW}  Claude failed (attempt $attempt/$MAX_RETRIES, exit code $exit_code)${NC}"
            echo -e "${RED}  Error: 'only prompt commands are supported in streaming mode'${NC}"
        else
            echo -e "${YELLOW}  Claude failed (attempt $attempt/$MAX_RETRIES, exit code $exit_code)${NC}"
        fi

        # Log failure details including the actual prompt
        log_failure "$phase" "$attempt" "$exit_code" "$output" "$prompt_size" "$prompt"

        if [[ $attempt -lt $MAX_RETRIES ]]; then
            echo -e "${YELLOW}  Retrying in ${RETRY_DELAY}s...${NC}"
            sleep $RETRY_DELAY
        fi

        ((attempt++))
    done

    echo -e "${RED}  All $MAX_RETRIES attempts failed${NC}"
    log "ERROR" "$phase phase failed after $MAX_RETRIES attempts"
    return 1
}

#==============================================================================
# INIT COMMAND - Bootstrap from idea file (works on new or existing projects)
#==============================================================================
if [[ "$1" == "init" ]]; then
    # Parse --safe flag and idea file
    INIT_SAFE_MODE=false
    IDEA_FILE=""

    shift  # Remove "init" from args
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --safe)
                INIT_SAFE_MODE=true
                shift
                ;;
            *)
                IDEA_FILE="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$IDEA_FILE" ]]; then
        echo -e "${RED}Usage: bjarne init [--safe] <idea.md>${NC}"
        exit 1
    fi

    if [[ ! -f "$IDEA_FILE" ]]; then
        echo -e "${RED}Error: $IDEA_FILE not found${NC}"
        exit 1
    fi

    # Detect if this is an existing project (has source code files)
    EXISTING_PROJECT="false"
    SRC_FILES=$(find . -maxdepth 3 -type f \( -name "*.js" -o -name "*.ts" -o -name "*.py" -o -name "*.php" -o -name "*.go" -o -name "*.rs" -o -name "*.java" -o -name "*.tsx" -o -name "*.jsx" \) 2>/dev/null | grep -v node_modules | grep -v vendor | grep -v __pycache__ | head -20)
    [[ -n "$SRC_FILES" ]] && EXISTING_PROJECT="true"

    if [[ "$EXISTING_PROJECT" == "true" ]]; then
        echo -e "${CYAN}Bjarne initializing EXISTING project from: $IDEA_FILE${NC}"
    else
        echo -e "${CYAN}Bjarne initializing NEW project from: $IDEA_FILE${NC}"
    fi

    # Detect existing environment
    DETECTED=""
    [[ -f "package.json" ]] && DETECTED="${DETECTED}Found: package.json (Node.js/JavaScript)\n"
    [[ -f "tsconfig.json" ]] && DETECTED="${DETECTED}Found: tsconfig.json (TypeScript)\n"
    [[ -f "composer.json" ]] && DETECTED="${DETECTED}Found: composer.json (PHP)\n"
    [[ -f "requirements.txt" ]] && DETECTED="${DETECTED}Found: requirements.txt (Python)\n"
    [[ -f "pyproject.toml" ]] && DETECTED="${DETECTED}Found: pyproject.toml (Python)\n"
    [[ -f "pubspec.yaml" ]] && DETECTED="${DETECTED}Found: pubspec.yaml (Flutter/Dart)\n"
    [[ -f "Cargo.toml" ]] && DETECTED="${DETECTED}Found: Cargo.toml (Rust)\n"
    [[ -f "go.mod" ]] && DETECTED="${DETECTED}Found: go.mod (Go)\n"
    [[ -f "CLAUDE.md" ]] && DETECTED="${DETECTED}Found: CLAUDE.md (existing project rules)\n"
    [[ -f ".env.example" ]] && DETECTED="${DETECTED}Found: .env.example (needs .env setup)\n"
    [[ -d "node_modules" ]] || [[ -f "package.json" ]] && [[ ! -d "node_modules" ]] && DETECTED="${DETECTED}Note: node_modules missing - needs npm install\n"
    [[ -d "vendor" ]] || [[ -f "composer.json" ]] && [[ ! -d "vendor" ]] && DETECTED="${DETECTED}Note: vendor missing - needs composer install\n"

    # For existing projects, include source file list
    EXISTING_CODE_INFO=""
    if [[ "$EXISTING_PROJECT" == "true" ]]; then
        EXISTING_CODE_INFO="
## EXISTING SOURCE FILES (explore these to understand what's built):
$SRC_FILES

This is an EXISTING project. You MUST:
1. Explore and understand the existing codebase structure
2. Read key files to understand what's already implemented
3. Document existing functionality in CONTEXT.md
4. Create tasks that BUILD ON existing code, not duplicate it
"
    fi

    read -r -d '' INIT_PROMPT << 'INIT_EOF' || true
# PROJECT INITIALIZATION

You have an idea file (freeform, any format) and detected environment info.
Your job: Create project structure that SUPPORTS the user's vision.

## Core Principle: RESPECT THE IDEA
- User's idea is the source of truth - don't change their concept
- If they specified something, use it exactly
- If they didn't specify, infer sensibly from context
- Fill gaps to make it buildable, but preserve their intent
- A detailed spec needs less inference; a vague idea needs more

## Phase 1: Understand
1. Read the idea file - extract what the user actually wants
2. Identify what's SPECIFIED (use as-is) vs what's UNSPECIFIED (infer)
3. Check detected environment for existing tech stack
4. If CLAUDE.md exists, read for existing project rules
5. **IF EXISTING PROJECT**: Explore the codebase! Read source files to understand:
   - What's already built
   - Code patterns and architecture used
   - What the idea is asking to ADD or CHANGE vs what exists

## Phase 2: Infer Missing Pieces (only if not specified)
For anything the user didn't specify, make smart choices:
- Tech stack: Use detected, or pick appropriate for project type
- Architecture: Simple and appropriate for scope (or follow existing patterns)
- Scope: Take idea at face value - don't expand or reduce

## Testing Principle: IF YOU CAN'T TEST IT, BUILD A WAY TO TEST IT
Unless user explicitly says "no tests", you MUST include testing:
- Add test framework setup task early (jest, pytest, vitest, etc.)
- Include test tasks for each major feature
- Tests enable the REVIEW step to verify work automatically
- Without tests, the feedback loop is blind
- Even simple projects benefit from basic smoke tests

## Phase 3: Create Files

### 1. CONTEXT.md (static reference for development)
```markdown
# [Project Name from idea]

## What We're Building
[User's vision - preserve their words/intent]

## Existing Codebase (if applicable)
[Summary of what already exists - key files, patterns, architecture]

## Tech Stack
[Detected or inferred]

## Commands
- Build: [detected or standard]
- Test: [detected or standard]
- Run: [detected or standard]

## Key Decisions
[Only if user specified preferences, constraints, or requirements]

## References
- specs/ for detailed specifications
```

### 2. TASKS.md
Break the idea into atomic tasks WITH VERIFIABLE OUTCOMES:
- Setup tasks first (if node_modules/vendor/.env missing)
- **For existing projects**: Tasks should reference existing code to modify/extend
- Then features from the idea (in logical order)
- Each task completable in one iteration
- **Format: `- [ ] Action â†’ Outcome`**
  - Action: What to implement
  - Outcome: How to verify it worked (must be machine-checkable)
- Examples:
  - `- [ ] Add login button to navbar â†’ Button with href="/login" exists in header`
  - `- [ ] Create /api/users endpoint â†’ GET /api/users returns 200 with JSON array`
  - `- [ ] Add email validation â†’ Invalid email shows error message`
- Number of tasks should match project scope (don't pad)

### 3. specs/ folder (only if needed)
Create specs that ADD VALUE - don't create empty scaffolds:
- API project with endpoints â†’ specs/API.md with routes, payloads
- UI with specific design â†’ specs/DESIGN_SYSTEM.md
- Complex data model â†’ specs/DATA_MODEL.md
- Skip specs that would just repeat the idea

## What NOT to Do
- Don't add features the user didn't ask for
- Don't create specs that just restate obvious things
- Don't expand scope beyond what they described
- Don't change their architectural choices if specified
- Don't add "nice to have" tasks - stick to the idea
- **For existing projects**: Don't recreate what already exists!

Read the idea, understand the vision, build the support structure.
INIT_EOF

    IDEA_CONTENT=$(cat "$IDEA_FILE")

    # Read CLAUDE.md if exists
    CLAUDE_MD=""
    if [[ -f "CLAUDE.md" ]]; then
        CLAUDE_MD="

## Existing CLAUDE.md (project rules to respect):
$(cat CLAUDE.md)
"
    fi

    run_claude "# IDEA FILE CONTENT:

$IDEA_CONTENT

---

## DETECTED ENVIRONMENT:
$DETECTED
$EXISTING_CODE_INFO
$CLAUDE_MD
---

$INIT_PROMPT" "INIT"

    # Verify files were created
    if [[ -f "$CONTEXT_FILE" ]] && [[ -f "$TASK_FILE" ]]; then
        echo -e "${GREEN}Project initialized!${NC}"
        echo -e "  - $CONTEXT_FILE"
        echo -e "  - $TASK_FILE"
        [[ -d "$SPECS_DIR" ]] && echo -e "  - $SPECS_DIR/"

        # Init git repo if git available and not already in a repo
        if command -v git &> /dev/null; then
            if ! git rev-parse --git-dir &> /dev/null 2>&1; then
                git init -q && \
                git add -A && \
                git commit -q -m "Initial project setup by Bjarne" && \
                echo -e "  - git repo initialized" || true
            fi
        fi

        # Generate Docker config if --safe flag was used
        if [[ "$INIT_SAFE_MODE" == true ]]; then
            echo -e "${CYAN}Generating Docker configuration for safe mode...${NC}"
            generate_dockerfile

            # Add .bjarne to .gitignore if not already there
            if [[ -f ".gitignore" ]]; then
                if ! grep -q "^\.bjarne/" ".gitignore" 2>/dev/null; then
                    echo ".bjarne/" >> ".gitignore"
                fi
            else
                echo ".bjarne/" > ".gitignore"
            fi
            echo -e "  - Added .bjarne/ to .gitignore"

            echo ""
            echo -e "${GREEN}Safe mode enabled!${NC}"
            echo -e "Container will only have access to this project directory."
        fi

        echo ""
        echo -e "${CYAN}Run 'bjarne' to start development${NC}"
    else
        echo -e "${RED}Initialization incomplete - check output above${NC}"
    fi

    exit 0
fi

#==============================================================================
# REBUILD COMMAND - Force rebuild Docker image
#==============================================================================
if [[ "$1" == "--rebuild" ]]; then
    detect_safe_mode

    if [[ "$SAFE_MODE" != true ]]; then
        echo -e "${RED}Error: Not a safe mode project (no $DOCKERFILE found)${NC}"
        echo -e "Run 'bjarne init --safe <idea.md>' to enable safe mode"
        exit 1
    fi

    echo -e "${CYAN}Rebuilding Docker image...${NC}"
    build_docker_image "true"
    exit 0
fi

#==============================================================================
# REFRESH COMMAND - Add tasks from freeform notes
#==============================================================================
if [[ "$1" == "refresh" ]]; then
    NOTES_FILE="$2"

    if [[ -z "$NOTES_FILE" ]]; then
        echo -e "${RED}Usage: bjarne refresh <notes.md>${NC}"
        exit 1
    fi

    if [[ ! -f "$NOTES_FILE" ]]; then
        echo -e "${RED}Error: $NOTES_FILE not found${NC}"
        exit 1
    fi

    if [[ ! -f "$CONTEXT_FILE" ]]; then
        echo -e "${RED}Error: $CONTEXT_FILE not found - run 'bjarne init' first${NC}"
        exit 1
    fi

    if [[ ! -f "$TASK_FILE" ]]; then
        echo -e "${RED}Error: $TASK_FILE not found - run 'bjarne init' first${NC}"
        exit 1
    fi

    echo -e "${CYAN}Bjarne refreshing project from: $NOTES_FILE${NC}"

    read -r -d '' REFRESH_PROMPT << 'REFRESH_EOF' || true
# PROJECT REFRESH

You have freeform notes from the user after testing/reviewing the project.
Your job: Update CONTEXT.md if needed and ADD new tasks to TASKS.md.

## The Notes May Contain
- Bug reports from manual testing
- New feature requests
- Tweaks and adjustments needed
- Things that didn't work as expected
- New ideas to add

## Your Job
1. Read the notes file carefully
2. Read current CONTEXT.md to understand the project
3. Read current TASKS.md to see what's done and what's pending
4. Explore relevant code if needed to understand the issues

## What to Update

### CONTEXT.md (only if needed)
- Add new architectural decisions if the notes change direction
- Update "What We're Building" only if scope genuinely changed
- Usually you WON'T need to change CONTEXT.md

### TASKS.md (main update)
- KEEP all existing tasks (completed and pending)
- ADD new tasks at the bottom based on the notes
- Group related new tasks together
- Each task should be atomic (one iteration)
- **Format: `- [ ] Action â†’ Outcome`** (outcome must be machine-verifiable)

## Task Naming (always include â†’ Outcome)
- Bug fix: `- [ ] Fix: [bug] â†’ [expected behavior after fix]`
- New feature: `- [ ] Add: [feature] â†’ [how to verify it works]`
- Tweak/adjust: `- [ ] Adjust: [change] â†’ [what should be different]`
- Refactor: `- [ ] Refactor: [target] â†’ [verification that behavior unchanged]`

## What NOT to Do
- Don't remove or reorder existing tasks
- Don't mark tasks complete (that's for the dev loop)
- Don't expand beyond what's in the notes
- Don't duplicate existing tasks

Read the notes, understand what's needed, update the project.
REFRESH_EOF

    NOTES_CONTENT=$(cat "$NOTES_FILE")
    CONTEXT_CONTENT=$(cat "$CONTEXT_FILE")
    TASKS_CONTENT=$(cat "$TASK_FILE")

    # Read CLAUDE.md if exists
    CLAUDE_MD=""
    if [[ -f "CLAUDE.md" ]]; then
        CLAUDE_MD="
## Project Rules (from CLAUDE.md):
$(cat CLAUDE.md)
"
    fi

    run_claude "# USER'S NOTES:

$NOTES_CONTENT

---

## CURRENT CONTEXT.md:
$CONTEXT_CONTENT

---

## CURRENT TASKS.md:
$TASKS_CONTENT

$CLAUDE_MD
---

$REFRESH_PROMPT" "REFRESH"

    # Show result
    NEW_TASKS=$(grep -c '^\s*- \[ \]' "$TASK_FILE" 2>/dev/null || echo "0")
    echo -e "${GREEN}Project refreshed!${NC}"
    echo -e "  - $NEW_TASKS pending tasks in $TASK_FILE"
    echo ""
    echo -e "${CYAN}Run 'bjarne' to work through the new tasks${NC}"

    exit 0
fi

#==============================================================================
# TASK COMMAND - Isolated single-task mode
#==============================================================================
if [[ "$1" == "task" ]]; then
    shift  # Remove "task" from args

    # Parse task command arguments
    TASK_SAFE_MODE=false
    TASK_DESCRIPTION=""
    TASK_FILE_INPUT=""
    TASK_BRANCH_OVERRIDE=""
    TASK_NO_PR=false
    TASK_MAX_ITERATIONS=25

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --safe)
                TASK_SAFE_MODE=true
                shift
                ;;
            -f|--file)
                TASK_FILE_INPUT="$2"
                shift 2
                ;;
            --branch)
                TASK_BRANCH_OVERRIDE="$2"
                shift 2
                ;;
            --no-pr)
                TASK_NO_PR=true
                shift
                ;;
            -n)
                TASK_MAX_ITERATIONS="$2"
                shift 2
                ;;
            *)
                # Assume it's the task description
                TASK_DESCRIPTION="$1"
                shift
                ;;
        esac
    done

    # Get description from file if -f was used
    if [[ -n "$TASK_FILE_INPUT" ]]; then
        if [[ ! -f "$TASK_FILE_INPUT" ]]; then
            echo -e "${RED}Error: Task file '$TASK_FILE_INPUT' not found${NC}"
            exit 1
        fi
        TASK_DESCRIPTION=$(cat "$TASK_FILE_INPUT")
    fi

    if [[ -z "$TASK_DESCRIPTION" ]]; then
        echo -e "${RED}Usage: bjarne task [--safe] [-f file.md] [--branch name] [--no-pr] [-n iterations] \"task description\"${NC}"
        echo ""
        echo "Examples:"
        echo "  bjarne task \"Fix the login button not responding\""
        echo "  bjarne task -f bugfix.md"
        echo "  bjarne task --safe \"Add payment integration\""
        echo "  bjarne task --branch feature/oauth \"Add OAuth support\""
        exit 1
    fi

    # Detect git and gh availability
    HAS_GIT=$(detect_git)
    HAS_GH=$(detect_gh)

    # Generate task ID and paths
    TASK_ID=$(generate_task_id "$TASK_DESCRIPTION")
    TASK_DIR=".bjarne/tasks/$TASK_ID"
    TASK_LOG_DIR="$TASK_DIR/logs"
    TASK_LOG_FILE="$TASK_LOG_DIR/task.log"
    TASK_SUBTASKS="$TASK_DIR/SUBTASKS.md"
    TASK_STATE_FILE="$TASK_DIR/.task"
    TASK_SUMMARY_FILE="$TASK_DIR/summary.md"
    TASK_ORIGINAL_FILE="$TASK_DIR/TASK.md"

    # Create task directory structure
    mkdir -p "$TASK_LOG_DIR"
    echo "$TASK_DESCRIPTION" > "$TASK_ORIGINAL_FILE"

    echo -e "${CYAN}Bjarne task mode${NC}"
    echo -e "  Task ID: $TASK_ID"
    echo -e "  Task dir: $TASK_DIR"
    echo -e "  Git available: $([ \"$HAS_GIT\" == \"1\" ] && echo \"yes\" || echo \"no\")"
    echo -e "  GitHub CLI: $([ \"$HAS_GH\" == \"1\" ] && echo \"yes\" || echo \"no\")"

    # Task-specific log function
    task_log() {
        local level="$1"
        local msg="$2"
        local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        echo "[$timestamp] [$level] $msg" >> "$TASK_LOG_FILE"
    }

    task_log "INFO" "=== Task session started ==="
    task_log "INFO" "Task: $TASK_DESCRIPTION"
    task_log "INFO" "Task ID: $TASK_ID"

    # Save original branch if git available
    ORIGINAL_BRANCH=""
    if [[ "$HAS_GIT" == "1" ]]; then
        ORIGINAL_BRANCH=$(git rev-parse --abbrev-ref HEAD)
        task_log "INFO" "Original branch: $ORIGINAL_BRANCH"

        # Create feature branch
        BRANCH_NAME="${TASK_BRANCH_OVERRIDE:-task/$TASK_ID}"
        echo -e "  Creating branch: $BRANCH_NAME"

        if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
            echo -e "${YELLOW}  Branch '$BRANCH_NAME' already exists, using it${NC}"
            git checkout "$BRANCH_NAME"
        else
            git checkout -b "$BRANCH_NAME"
        fi
        task_log "INFO" "Working branch: $BRANCH_NAME"
    fi

    # Handle safe mode for task
    if [[ "$TASK_SAFE_MODE" == true ]]; then
        if [[ ! -f "$DOCKERFILE" ]]; then
            echo -e "${CYAN}Generating Docker configuration for safe mode...${NC}"
            generate_dockerfile
        fi
        SAFE_MODE=true
        PROJECT_NAME=$(basename "$(pwd)" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g')
        IMAGE_NAME="bjarne-${PROJECT_NAME}"
        build_docker_image "false"
    fi

    echo ""

    # Read project context if available (read-only)
    PROJECT_CONTEXT=""
    if [[ -f "$CONTEXT_FILE" ]]; then
        PROJECT_CONTEXT="## PROJECT CONTEXT (from CONTEXT.md):
$(cat "$CONTEXT_FILE")

"
    fi

    # Read specs if available (read-only)
    SPECS_CONTENT=""
    if [[ -d "$SPECS_DIR" ]]; then
        SPECS_FILES=$(find "$SPECS_DIR" -name "*.md" 2>/dev/null)
        if [[ -n "$SPECS_FILES" ]]; then
            SPECS_CONTENT="## SPECIFICATIONS (from specs/):
$(cat $SPECS_DIR/*.md 2>/dev/null)

"
        fi
    fi

    # Read CLAUDE.md if exists
    CLAUDE_MD_CONTENT=""
    if [[ -f "CLAUDE.md" ]]; then
        CLAUDE_MD_CONTENT="## Project Rules (from CLAUDE.md):
$(cat CLAUDE.md)

"
    fi

    #--------------------------------------------------------------------------
    # DECOMPOSE PHASE - Break task into subtasks
    #--------------------------------------------------------------------------
    echo -e "${BLUE}[DECOMPOSE]${NC} Breaking down task..."

    read -r -d '' DECOMPOSE_PROMPT << 'DECOMPOSE_EOF' || true
# DECOMPOSE TASK

You are breaking down a task for an autonomous coding agent.

CRITICAL: You are working on an EXISTING project. Do NOT delete any source files,
configuration files, or project files. Only modify files directly related to this task.
The project's existing files are NOT bjarne artifacts - do NOT remove them.

## Instructions
1. Explore the codebase to understand the relevant code
2. Break this into discrete subtasks (or keep as one if simple enough)
3. Each subtask must have: Action â†’ Outcome (verifiable)
4. Output ONLY a markdown checklist to SUBTASKS.md file

## Subtask Format
Each line must be: `- [ ] Action â†’ Outcome`
- Action: What to implement (specific, atomic)
- Outcome: How to verify it worked (must be machine-checkable)

## Examples
- [ ] Find login button component â†’ Located in src/components/
- [ ] Add onClick handler to login button â†’ Button calls handleLogin function when clicked
- [ ] Test login flow â†’ Clicking login button redirects to /dashboard

## Output
Write ONLY the subtask checklist to the SUBTASKS.md file. Nothing else.
Keep subtasks focused, atomic, and verifiable.
DECOMPOSE_EOF

    DECOMPOSE_FULL_PROMPT="# TASK TO DECOMPOSE:
$TASK_DESCRIPTION

---

$PROJECT_CONTEXT$SPECS_CONTENT$CLAUDE_MD_CONTENT---

Write subtasks to: $TASK_SUBTASKS

$DECOMPOSE_PROMPT"

    if ! run_claude "$DECOMPOSE_FULL_PROMPT" "DECOMPOSE"; then
        echo -e "${RED}Decompose phase failed - aborting${NC}"
        if [[ "$HAS_GIT" == "1" ]] && [[ -n "$ORIGINAL_BRANCH" ]]; then
            git checkout "$ORIGINAL_BRANCH" 2>/dev/null
        fi
        exit 1
    fi

    # Verify SUBTASKS.md was created
    if [[ ! -f "$TASK_SUBTASKS" ]]; then
        echo -e "${RED}Error: SUBTASKS.md not created${NC}"
        if [[ "$HAS_GIT" == "1" ]] && [[ -n "$ORIGINAL_BRANCH" ]]; then
            git checkout "$ORIGINAL_BRANCH" 2>/dev/null
        fi
        exit 1
    fi

    SUBTASK_COUNT=$(grep -c '^\s*- \[ \]' "$TASK_SUBTASKS" 2>/dev/null || echo "0")
    echo -e "${GREEN}Created $SUBTASK_COUNT subtasks${NC}"
    echo ""

    #--------------------------------------------------------------------------
    # TASK LOOP - Run until all subtasks complete
    # Uses main prompts with task-mode context injection
    #--------------------------------------------------------------------------

    # Build task mode context header (injected before each prompt)
    TASK_MODE_HEADER="## TASK MODE - Isolated Single Fix

**File Mappings (read these instead of defaults):**
- TASKS.md â†’ $TASK_SUBTASKS
- .task â†’ $TASK_STATE_FILE

**Task Mode Rules:**
- You are fixing ONE specific thing in an EXISTING project
- Do NOT delete any project source files - only modify what's needed for this task
- Do NOT create new test infrastructure if none exists
- If tests exist and this change naturally fits, add/update tests
- If no tests exist, outcome verification (grep, curl, file check) is sufficient

"

    echo -e "${CYAN}Starting task loop - max $TASK_MAX_ITERATIONS iterations${NC}"
    echo ""

    for i in $(seq 1 $TASK_MAX_ITERATIONS); do
        # Check for remaining subtasks
        if ! grep -q '^\s*- \[ \]' "$TASK_SUBTASKS"; then
            echo -e "${GREEN}All subtasks complete!${NC}"
            break
        fi

        REMAINING=$(grep -c '^\s*- \[ \]' "$TASK_SUBTASKS") || REMAINING=0
        echo -e "${YELLOW}=== Task iteration $i/$TASK_MAX_ITERATIONS ($REMAINING subtasks remaining) ===${NC}"

        # Build context for this iteration (task mode header + project context)
        ITER_CONTEXT="$TASK_MODE_HEADER$PROJECT_CONTEXT$SPECS_CONTENT$CLAUDE_MD_CONTENT"

        # PLAN (uses main PLAN_PROMPT with task context)
        echo -e "${BLUE}[1/4 PLAN]${NC} Analyzing subtask..."
        if ! run_claude "$ITER_CONTEXT

$PLAN_PROMPT" "TASK_PLAN"; then
            echo -e "${RED}Plan phase failed - aborting${NC}"
            break
        fi

        if [[ ! -f "$TASK_STATE_FILE" ]]; then
            echo -e "${RED}Plan failed - no .task file created${NC}"
            continue
        fi

        # EXECUTE (uses main EXECUTE_PROMPT with task context)
        echo -e "${BLUE}[2/4 EXECUTE]${NC} Implementing..."
        if ! run_claude "$ITER_CONTEXT

$EXECUTE_PROMPT" "TASK_EXECUTE"; then
            echo -e "${RED}Execute phase failed - aborting${NC}"
            break
        fi

        # REVIEW (uses main REVIEW_PROMPT with task context)
        echo -e "${BLUE}[3/4 REVIEW]${NC} Reviewing..."
        if ! run_claude "$ITER_CONTEXT

$REVIEW_PROMPT" "TASK_REVIEW"; then
            echo -e "${RED}Review phase failed - aborting${NC}"
            break
        fi

        # FIX (uses main FIX_PROMPT with task context)
        echo -e "${BLUE}[4/4 FIX]${NC} Fixing..."
        if ! run_claude "$ITER_CONTEXT

$FIX_PROMPT" "TASK_FIX"; then
            echo -e "${RED}Fix phase failed - aborting${NC}"
            break
        fi

        sleep 2
    done

    #--------------------------------------------------------------------------
    # FINALIZE - Generate summary and create PR
    #--------------------------------------------------------------------------
    echo ""
    echo -e "${CYAN}Finalizing task...${NC}"

    # Count completed subtasks (grep -c returns 0 on no match but exits non-zero, so we need || true)
    COMPLETED_COUNT=$(grep -c '^\s*- \[x\]' "$TASK_SUBTASKS" 2>/dev/null) || COMPLETED_COUNT=0
    REMAINING_COUNT=$(grep -c '^\s*- \[ \]' "$TASK_SUBTASKS" 2>/dev/null) || REMAINING_COUNT=0

    # Generate summary
    SUMMARY="# Task Summary

## Original Task
$TASK_DESCRIPTION

## Results
- Completed subtasks: $COMPLETED_COUNT
- Remaining subtasks: $REMAINING_COUNT
"

    if [[ "$HAS_GIT" == "1" ]]; then
        # Get git diff stats
        DIFF_STAT=$(git diff "$ORIGINAL_BRANCH"..HEAD --stat 2>/dev/null || echo "No changes")
        COMMIT_LOG=$(git log "$ORIGINAL_BRANCH"..HEAD --oneline 2>/dev/null || echo "No commits")

        SUMMARY+="
## Changes
\`\`\`
$DIFF_STAT
\`\`\`

## Commits
\`\`\`
$COMMIT_LOG
\`\`\`
"
    fi

    SUMMARY+="
## Subtasks
$(cat "$TASK_SUBTASKS")
"

    echo "$SUMMARY" > "$TASK_SUMMARY_FILE"

    # Output summary
    echo ""
    echo -e "${GREEN}========================================${NC}"
    echo -e "${GREEN}TASK COMPLETE${NC}"
    echo -e "${GREEN}========================================${NC}"
    echo ""
    echo -e "Completed: $COMPLETED_COUNT subtasks"
    echo -e "Remaining: $REMAINING_COUNT subtasks"

    if [[ "$HAS_GIT" == "1" ]]; then
        echo -e "Branch: $BRANCH_NAME"

        # Check if there are actual changes to push
        COMMIT_COUNT=$(git rev-list "$ORIGINAL_BRANCH"..HEAD --count 2>/dev/null || echo "0")

        if [[ "$COMMIT_COUNT" -gt 0 ]]; then
            # Push branch
            echo -e "\n${CYAN}Pushing branch to remote...${NC}"
            if git push -u origin "$BRANCH_NAME" 2>/dev/null; then
                echo -e "${GREEN}Branch pushed successfully${NC}"

                # Create PR if gh available and not --no-pr
                if [[ "$HAS_GH" == "1" ]] && [[ "$TASK_NO_PR" != true ]]; then
                    echo -e "\n${CYAN}Creating pull request...${NC}"

                    PR_TITLE="[Bjarne Task] $(echo "$TASK_DESCRIPTION" | head -c 60)"
                    PR_BODY="## Summary
$TASK_DESCRIPTION

## Changes
- Completed $COMPLETED_COUNT subtask(s)

## Subtasks
$(cat "$TASK_SUBTASKS")

---
*Generated by bjarne task mode*"

                    if PR_URL=$(gh pr create --title "$PR_TITLE" --body "$PR_BODY" 2>/dev/null); then
                        echo -e "${GREEN}Pull request created: $PR_URL${NC}"
                    else
                        echo -e "${YELLOW}Could not create PR (may already exist or no remote)${NC}"
                        echo -e "Create manually: gh pr create --title \"$PR_TITLE\""
                    fi
                elif [[ "$TASK_NO_PR" == true ]]; then
                    echo -e "\n${YELLOW}Skipping PR creation (--no-pr flag)${NC}"
                else
                    echo -e "\n${YELLOW}GitHub CLI not available - create PR manually:${NC}"
                    echo -e "  gh pr create --title \"[Bjarne Task] $TASK_DESCRIPTION\""
                fi
            else
                echo -e "${YELLOW}Could not push branch (no remote or access denied)${NC}"
            fi
        else
            echo -e "${YELLOW}No commits made - nothing to push${NC}"
        fi

        # Return to original branch
        echo -e "\n${CYAN}Returning to original branch: $ORIGINAL_BRANCH${NC}"
        git checkout "$ORIGINAL_BRANCH" 2>/dev/null
    else
        echo -e "\n${YELLOW}Git not available - changes made to working directory only${NC}"
    fi

    # Cleanup task state directory
    echo -e "\n${CYAN}Cleaning up task state...${NC}"
    rm -rf "$TASK_DIR"
    echo -e "${GREEN}Task state cleaned up${NC}"

    # Final summary output
    echo ""
    echo -e "${GREEN}Task Summary:${NC}"
    echo "---"
    echo "$SUMMARY"
    echo "---"
    exit 0
fi

#==============================================================================
# MAIN LOOP - PLAN â†’ EXECUTE â†’ REVIEW â†’ FIX
#==============================================================================

MAX_ITERATIONS=${1:-25}

# Check required files
if [[ ! -f "$TASK_FILE" ]]; then
    echo -e "${RED}Error: $TASK_FILE not found${NC}"
    echo -e "Run 'bjarne init <idea.md>' first"
    exit 1
fi

if [[ ! -f "$CONTEXT_FILE" ]]; then
    echo -e "${YELLOW}Warning: $CONTEXT_FILE not found${NC}"
fi

# Main mode testing guidance (injected into context)
MAIN_MODE_HEADER="## DEVELOPMENT MODE - Testing Requirements

**Testing is CRITICAL for the feedback loop:**
- If no tests exist yet â†’ flag as ðŸŸ¡ ISSUE: \"No tests - add test for this feature\"
- If tests exist but don't cover new code â†’ flag as ðŸŸ¡ ISSUE: \"Add test coverage\"
- Tests let you VERIFY the implementation works - without them you're blind
- A feature without tests is not truly complete

"

# Load context fresh each iteration
load_context() {
    CONTEXT="$MAIN_MODE_HEADER"
    if [[ -f "$CONTEXT_FILE" ]]; then
        CONTEXT+=$(cat "$CONTEXT_FILE")
    fi
    # Also include CLAUDE.md if exists (project rules)
    if [[ -f "CLAUDE.md" ]]; then
        CONTEXT="$CONTEXT

## Project Rules (from CLAUDE.md):
$(cat CLAUDE.md)"
    fi
}

# Detect and setup safe mode if applicable
detect_safe_mode
if [[ "$SAFE_MODE" == true ]]; then
    echo -e "${CYAN}Safe mode detected (.bjarne/Dockerfile found)${NC}"
    build_docker_image "false"
    echo ""
fi

# Log session start
log "INFO" "=== Bjarne session started ==="
log "INFO" "Max iterations: $MAX_ITERATIONS, Safe mode: $SAFE_MODE"
log "INFO" "Working directory: $(pwd)"

echo -e "${CYAN}Bjarne starting - max $MAX_ITERATIONS iterations${NC}"
echo -e "${CYAN}Loop: PLAN â†’ EXECUTE â†’ REVIEW â†’ FIX${NC}"
echo -e "${CYAN}Logs: $LOG_FILE${NC}"
echo ""

for i in $(seq 1 $MAX_ITERATIONS); do
    # Load context fresh each iteration
    load_context

    # Check for remaining tasks
    if ! grep -q '^\s*- \[ \]' "$TASK_FILE"; then
        echo -e "${GREEN}All tasks complete!${NC}"
        rm -f "$TASK_STATE"
        exit 0
    fi

    REMAINING=$(grep -c '^\s*- \[ \]' "$TASK_FILE" || echo "0")
    echo -e "${YELLOW}=== Iteration $i/$MAX_ITERATIONS ($REMAINING tasks remaining) ===${NC}"

    # PLAN
    echo -e "${BLUE}[1/4 PLAN]${NC} Analyzing..."
    if ! run_claude "$CONTEXT

$PLAN_PROMPT" "PLAN"; then
        echo -e "${RED}Plan phase failed after $MAX_RETRIES retries - aborting${NC}"
        exit 1
    fi

    if [[ ! -f "$TASK_STATE" ]]; then
        echo -e "${RED}Plan failed - no .task file${NC}"
        continue
    fi

    # EXECUTE
    echo -e "${BLUE}[2/4 EXECUTE]${NC} Implementing..."
    if ! run_claude "$CONTEXT

$EXECUTE_PROMPT" "EXECUTE"; then
        echo -e "${RED}Execute phase failed after $MAX_RETRIES retries - aborting${NC}"
        exit 1
    fi

    # REVIEW
    echo -e "${BLUE}[3/4 REVIEW]${NC} Reviewing..."
    if ! run_claude "$CONTEXT

$REVIEW_PROMPT" "REVIEW"; then
        echo -e "${RED}Review phase failed after $MAX_RETRIES retries - aborting${NC}"
        exit 1
    fi

    # FIX
    echo -e "${BLUE}[4/4 FIX]${NC} Fixing..."
    if ! run_claude "$CONTEXT

$FIX_PROMPT" "FIX"; then
        echo -e "${RED}Fix phase failed after $MAX_RETRIES retries - aborting${NC}"
        exit 1
    fi

    sleep 2
done

echo -e "${YELLOW}Max iterations reached${NC}"
