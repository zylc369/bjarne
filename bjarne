#!/bin/bash
# Bjarne - Autonomous AI development system
#
# Commands:
#   bjarne init [--safe] <idea.md>  - Bootstrap project from idea file
#   bjarne refresh <notes.md>       - Add tasks from freeform notes
#   bjarne task [opts] "desc"       - Run isolated single-task mode
#   bjarne [opts] [n]               - Run n iterations (default 25)
#   bjarne --rebuild                - Force rebuild Docker image (safe mode only)
#   bjarne --disable-auto-update    - Disable automatic update checks
#   bjarne --enable-auto-update     - Re-enable automatic update checks
#
# Main loop options:
#   --batch             - Enable batch mode (up to 5 related tasks per iteration)
#   --batch=N, -bN      - Enable batch mode with custom size (up to N tasks)
#                         Tasks are grouped by natural relatedness, not forced
#
# Task mode options:
#   --safe              - Run in Docker container
#   -f, --file <file>   - Read task description from file
#   --branch <name>     - Use custom branch name
#   --no-pr             - Skip PR creation
#   -n <num>            - Max iterations (default 25)
#
# Safe mode (--safe): Runs Claude in a Docker container that can only access
# the project directory. Use for unattended runs to prevent accidental
# damage to other files on the system.
#
# Loop: PLAN â†’ EXECUTE â†’ REVIEW â†’ FIX
#
# Task mode: Isolated single-task fixes. Does NOT touch CONTEXT.md, TASKS.md.
# Uses .bjarne/tasks/<task-id>/ for state. Auto-creates branch and PR if git/gh available.
#
# idea.md/notes.md are freeform - write whatever you want. Bjarne will figure it out.

set -e

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
RED='\033[0;31m'
CYAN='\033[0;36m'
NC='\033[0m'

# Files
TASK_FILE="TASKS.md"
CONTEXT_FILE="CONTEXT.md"
SPECS_DIR="specs"
TASK_STATE=".task"

# Retry settings
MAX_RETRIES=5
RETRY_DELAY=10

SCRIPT_DIR="$(dirname "${BASH_SOURCE[0]}")"

# Source library components
source "$SCRIPT_DIR/lib/consts.sh"
source "$SCRIPT_DIR/lib/prompts.sh"

echo "SCRIPT_DIR=$SCRIPT_DIR"
echo "BJARNE_HOME=$BJARNE_HOME"
echo "BJARNE_PROJECT_ROOT=$BJARNE_PROJECT_ROOT"
echo "LOG_DIR=$LOG_DIR"
echo "LOG_FILE=$LOG_FILE"

# Ensure log directory exists
mkdir -p "$LOG_DIR"

# Instance-specific temp folder for verbose command output
# Uses PID + timestamp for uniqueness across concurrent instances
BJARNE_INSTANCE_ID="$$_$(date +%s)"
BJARNE_TMP_DIR="/tmp/bjarne-${BJARNE_INSTANCE_ID}"
mkdir -p "$BJARNE_TMP_DIR"

# Cleanup function for temp folder
cleanup_temp() {
    if [[ -d "$BJARNE_TMP_DIR" ]]; then
        rm -rf "$BJARNE_TMP_DIR"
    fi
}

# Trap signals to ensure cleanup on exit (normal, interrupt, terminate)
# INT: ç”¨æˆ·æŒ‰ä¸‹ Ctrl+C æ—¶å‘é€çš„ä¸­æ–­ä¿¡å·ï¼Œå’ŒSIGINTç­‰åŒã€‚
# TERM: ç³»ç»Ÿå‘é€çš„ç»ˆæ­¢ä¿¡å·ï¼ˆå¦‚ kill å‘½ä»¤ï¼‰ï¼Œå’ŒSIGTERMç­‰åŒã€‚
# EXIT: æ˜¯ä¼ªä¿¡å·ï¼Œä»…åœ¨è„šæœ¬é€€å‡ºæ—¶è§¦å‘ï¼ˆæ— è®ºæ˜¯æ­£å¸¸é€€å‡ºè¿˜æ˜¯è¢«ä¿¡å·ä¸­æ–­ï¼‰ï¼Œä¼šæ•èŽ·ä»¥ä¸‹æ‰€æœ‰æƒ…å†µï¼š
#   1. è„šæœ¬æ­£å¸¸æ‰§è¡Œç»“æŸ
#   2. exit å‘½ä»¤
#   3. ä»»ä½•ä¿¡å·å¯¼è‡´çš„é€€å‡º
#   4. è„šæœ¬ä¸­ä»»ä½•é”™è¯¯ï¼ˆå¦‚æžœæœ‰set -eï¼‰
trap cleanup_temp EXIT INT TERM

# Log function
log() {
    local level="$1"
    local msg="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] [$level] $msg" >> "$LOG_FILE"
}

# Log with context (for failures)
log_failure() {
    local phase="$1"
    local attempt="$2"
    local exit_code="$3"
    local output="$4"
    local prompt_size="$5"
    local prompt="$6"

    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local fail_file="$LOG_DIR/failure_${timestamp//[: -]/_}.log"

    {
        echo "=== BJARNE FAILURE LOG ==="
        echo "Timestamp: $timestamp"
        echo "Phase: $phase"
        echo "Attempt: $attempt/$MAX_RETRIES"
        echo "Exit code: $exit_code"
        echo "Prompt size: $prompt_size bytes"
        echo "Working directory: $(pwd)"
        echo "Safe mode: $SAFE_MODE"
        echo ""
        echo "=== CLAUDE OUTPUT ==="
        echo "$output"
        echo ""
        echo "=== ACTUAL PROMPT SENT ==="
        echo "$prompt"
        echo ""
        echo "=== CURRENT .task FILE (if exists) ==="
        if [[ -f "$TASK_STATE" ]]; then
            cat "$TASK_STATE"
        else
            echo "(no .task file)"
        fi
    } > "$fail_file"

    log "ERROR" "Failure logged to $fail_file"
    echo -e "${YELLOW}  Failure details saved to: $fail_file${NC}"
}

# Safe mode (Docker) settings
BJARNE_DIR=".bjarne"
DOCKERFILE="$BJARNE_DIR/Dockerfile"
SAFE_MODE=false
IMAGE_NAME=""

#==============================================================================
# PROMPTS - Defined early so both task mode and main loop can use them
#==============================================================================

PLAN_PROMPT=$(cat "${SCRIPT_DIR}/resources/prompt_plan.md")
EXECUTE_PROMPT=$(cat "${SCRIPT_DIR}/resources/prompt_execute.md")
REVIEW_PROMPT=$(cat "${SCRIPT_DIR}/resources/prompt_review.md")
FIX_PROMPT=$(cat "${SCRIPT_DIR}/resources/prompt_fix.md")


#==============================================================================
# SAFE MODE FUNCTIONS
#==============================================================================

# Detect if project uses safe mode
detect_safe_mode() {
    if [[ -f "$DOCKERFILE" ]]; then
        # Check if Docker is available
        if ! command -v docker &>/dev/null; then
            echo -e "${RED}Error: Docker required for safe mode but not found${NC}"
            exit 1
        fi

        # Check if credentials exist
        if [[ ! -f "$HOME/.claude/.credentials.json" ]]; then
            echo -e "${RED}Error: Claude credentials not found at ~/.claude/.credentials.json${NC}"
            echo -e "Run 'claude' on the host first to authenticate"
            exit 1
        fi

        SAFE_MODE=true
        # Generate image name from current directory
        PROJECT_NAME=$(basename "$(pwd)" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g')
        IMAGE_NAME="bjarne-${PROJECT_NAME}"
    fi
}

# Build Docker image if needed
build_docker_image() {
    local force_rebuild="$1"

    if [[ "$force_rebuild" == "true" ]] || ! docker image inspect "$IMAGE_NAME" &>/dev/null 2>&1; then
        echo -e "${CYAN}Building Docker image: $IMAGE_NAME${NC}"
        docker build -t "$IMAGE_NAME" -f "$DOCKERFILE" . || {
            echo -e "${RED}Docker build failed${NC}"
            exit 1
        }
        echo -e "${GREEN}Image built successfully${NC}"
    else
        echo -e "${CYAN}Using cached image: $IMAGE_NAME${NC}"
    fi
}

# Get appropriate Docker base image for detected tech stack
get_base_image() {
    if [[ -f "package.json" ]]; then
        echo "node:22-bookworm"
    elif [[ -f "requirements.txt" ]] || [[ -f "pyproject.toml" ]]; then
        echo "python:3.12-bookworm"
    elif [[ -f "Cargo.toml" ]]; then
        echo "rust:1-bookworm"
    elif [[ -f "go.mod" ]]; then
        echo "golang:1.23-bookworm"
    elif [[ -f "composer.json" ]]; then
        echo "php:8.4-cli-bookworm"
    elif [[ -f "pubspec.yaml" ]]; then
        echo "dart:stable"
    else
        # Default to Node as it includes npm for Claude Code
        echo "node:22-bookworm"
    fi
}

# Get volume mount for tech-specific dependencies
get_dep_volume() {
    local project_name="$1"

    if [[ -f "package.json" ]]; then
        echo "${project_name}-node-modules:/workspace/node_modules"
    elif [[ -f "requirements.txt" ]] || [[ -f "pyproject.toml" ]]; then
        echo "${project_name}-venv:/workspace/.venv"
    elif [[ -f "Cargo.toml" ]]; then
        echo "${project_name}-target:/workspace/target"
    elif [[ -f "go.mod" ]]; then
        echo "${project_name}-gopath:/go"
    elif [[ -f "composer.json" ]]; then
        echo "${project_name}-vendor:/workspace/vendor"
    else
        echo ""
    fi
}

# Generate Dockerfile for safe mode
generate_dockerfile() {
    local base_image=$(get_base_image)

    mkdir -p "$BJARNE_DIR"

    cat > "$DOCKERFILE" << EOF
# Auto-generated by bjarne init --safe
# Modify as needed, then run: bjarne --rebuild

FROM $base_image

# Install Node.js if not present (needed for Claude Code CLI)
RUN command -v node >/dev/null 2>&1 || { \\
    apt-get update && apt-get install -y nodejs npm && rm -rf /var/lib/apt/lists/*; \\
}

# Install Claude Code CLI
RUN npm install -g @anthropic-ai/claude-code

# Install common dev tools
RUN apt-get update && apt-get install -y git curl && rm -rf /var/lib/apt/lists/*

# Create non-root user (Claude Code refuses --dangerously-skip-permissions as root)
# Make home directory world-writable so any UID can write (container is sandboxed anyway)
RUN useradd -m -s /bin/bash bjarne && \\
    mkdir -p /workspace && chown bjarne:bjarne /workspace && \\
    mkdir -p /home/bjarne/.claude && \\
    chmod -R 777 /home/bjarne
USER bjarne

WORKDIR /workspace
EOF

    echo -e "  - Generated $DOCKERFILE (base: $base_image)"
}

#==============================================================================
# GIT/GH DETECTION FUNCTIONS (for task command)
#==============================================================================

# Detect if git is available and we're in a repo
detect_git() {
    if command -v git &>/dev/null && git rev-parse --git-dir &>/dev/null 2>&1; then
        echo "1"
    else
        echo "0"
    fi
}

# Detect if gh CLI is available and authenticated
detect_gh() {
    if command -v gh &>/dev/null && gh auth status &>/dev/null 2>&1; then
        echo "1"
    else
        echo "0"
    fi
}

# Generate task ID from description (uses first line only for slug)
generate_task_id() {
    local description="$1"
    local timestamp=$(date +%s)
    # Use only first non-empty line for slug (handles multi-line markdown)
    local first_line=$(echo "$description" | grep -v '^#' | grep -v '^$' | head -1)
    local slug=$(echo "$first_line" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | cut -c1-30)
    echo "${timestamp}-${slug}"
}

# Run claude with retry logic (safe mode aware)
# Usage: run_claude "prompt" "PHASE_NAME"
run_claude() {
    local user_prompt="$1"
    local phase="${2:-UNKNOWN}"
    local attempt=1
    local exit_code
    local output

    # APPEND verbose output rules to ALL prompts (at end = more prominent)
    local prompt="$user_prompt

$(get_verbose_output_rules)"
    local prompt_size=${#prompt}

    log "INFO" "Starting $phase phase (prompt: $prompt_size bytes)"

    while [[ $attempt -le $MAX_RETRIES ]]; do
        if [[ "$SAFE_MODE" == true ]]; then
            # Run in Docker container (as 'bjarne' user, not root)
            local docker_args="-v $(pwd):/workspace"
            docker_args+=" -v $HOME/.claude/.credentials.json:/home/bjarne/.claude/.credentials.json:ro"

            # Add gh CLI config if available (for PR creation in task mode)
            if [[ -d "$HOME/.config/gh" ]]; then
                docker_args+=" -v $HOME/.config/gh:/home/bjarne/.config/gh:ro"
            fi

            # Add gitconfig if available (for commits)
            if [[ -f "$HOME/.gitconfig" ]]; then
                docker_args+=" -v $HOME/.gitconfig:/home/bjarne/.gitconfig:ro"
            fi

            # Add dependency volume if applicable
            local dep_volume=$(get_dep_volume "$PROJECT_NAME")
            if [[ -n "$dep_volume" ]]; then
                docker_args+=" -v $dep_volume"
            fi

            # Mount temp folder for verbose output logs (same path inside container)
            docker_args+=" -v $BJARNE_TMP_DIR:$BJARNE_TMP_DIR"

            # Capture both stdout and stderr
            # Run as host user's UID/GID so mounted files have correct permissions
            output=$(docker run --rm --user "$(id -u):$(id -g)" -e HOME=/home/bjarne \
                $docker_args -w /workspace "$IMAGE_NAME" \
                claude -p --dangerously-skip-permissions "$prompt" 2>&1)
            exit_code=$?
        else
            # Run on host (existing behavior), capture output
            output=$(claude -p --dangerously-skip-permissions "$prompt" 2>&1)
            exit_code=$?
        fi

        if [[ $exit_code -eq 0 ]]; then
            # Output the result (so it still shows on screen)
            echo "$output"
            log "INFO" "$phase phase completed successfully"
            return 0
        fi

        # Check for the specific streaming error
        if echo "$output" | grep -q "only prompt commands are supported in streaming mode"; then
            log "ERROR" "$phase: Got 'streaming mode' error (attempt $attempt)"
            echo -e "${YELLOW}  Claude failed (attempt $attempt/$MAX_RETRIES, exit code $exit_code)${NC}"
            echo -e "${RED}  Error: 'only prompt commands are supported in streaming mode'${NC}"
        else
            echo -e "${YELLOW}  Claude failed (attempt $attempt/$MAX_RETRIES, exit code $exit_code)${NC}"
        fi

        # Log failure details including the actual prompt
        log_failure "$phase" "$attempt" "$exit_code" "$output" "$prompt_size" "$prompt"

        if [[ $attempt -lt $MAX_RETRIES ]]; then
            echo -e "${YELLOW}  Retrying in ${RETRY_DELAY}s...${NC}"
            sleep $RETRY_DELAY
        fi

        ((attempt++))
    done

    echo -e "${RED}  All $MAX_RETRIES attempts failed${NC}"
    log "ERROR" "$phase phase failed after $MAX_RETRIES attempts"
    return 1
}

#==============================================================================
# INIT COMMAND - Bootstrap from idea file (works on new or existing projects)
#==============================================================================
if [[ "$1" == "init" ]]; then
    # Parse --safe flag and idea file
    INIT_SAFE_MODE=false
    IDEA_FILE=""

    shift  # Remove "init" from args
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --safe)
                INIT_SAFE_MODE=true
                shift
                ;;
            *)
                IDEA_FILE="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$IDEA_FILE" ]]; then
        echo -e "${RED}Usage: bjarne init [--safe] <idea.md>${NC}"
        exit 1
    fi

    if [[ ! -f "$IDEA_FILE" ]]; then
        echo -e "${RED}Error: $IDEA_FILE not found${NC}"
        exit 1
    fi

    # Detect if this is an existing project (has source code files)
    EXISTING_PROJECT="false"
    SRC_FILES=$(find . -maxdepth 3 -type f \( -name "*.sql" -o -name "*.html" -o -name "*.js" -o -name "*.ts" -o -name "*.py" -o -name "*.php" -o -name "*.go" -o -name "*.rs" -o -name "*.java" -o -name "*.tsx" -o -name "*.jsx" \) 2>/dev/null | grep -v node_modules | grep -v vendor | grep -v __pycache__ | head -20)
    # [[ -n "$SRC_FILES" ]] && EXISTING_PROJECT="true"
    # Prompt user to confirm
    if [[ -n "$SRC_FILES" ]]; then
        echo "æ£€æµ‹åˆ°æºä»£ç æ–‡ä»¶ã€‚"

        while true; do
            read -n1 -p "è¿™æ˜¯å¦æ˜¯ä¸€ä¸ªå·²å­˜åœ¨çš„é¡¹ç›®ï¼Ÿ(y/n): " yn
            echo ""  # æ‰‹åŠ¨æ¢è¡Œï¼Œä½¿ç•Œé¢æ•´æ´
            case $yn in
                [Yy])
                    EXISTING_PROJECT="true"
                    break
                    ;;
                [Nn])
                    EXISTING_PROJECT="false"
                    break
                    ;;
                *)
                    echo "è¯·è¾“å…¥ yï¼ˆæ˜¯ï¼‰æˆ– nï¼ˆå¦ï¼‰ã€‚"
                    ;;
            esac
        done
    else
        echo "æœªæ£€æµ‹åˆ°å¸¸è§æºä»£ç æ–‡ä»¶ï¼Œå‡è®¾ä¸ºæ–°é¡¹ç›®ã€‚"
    fi

    if [[ "$EXISTING_PROJECT" == "true" ]]; then
        echo -e "${CYAN}Bjarne initializing EXISTING project from: $IDEA_FILE${NC}"
    else
        echo -e "${CYAN}Bjarne initializing NEW project from: $IDEA_FILE${NC}"
    fi

    # Detect existing environment
    DETECTED=""
    [[ -f "package.json" ]] && DETECTED="${DETECTED}Found: package.json (Node.js/JavaScript)\n"
    [[ -f "tsconfig.json" ]] && DETECTED="${DETECTED}Found: tsconfig.json (TypeScript)\n"
    [[ -f "composer.json" ]] && DETECTED="${DETECTED}Found: composer.json (PHP)\n"
    [[ -f "requirements.txt" ]] && DETECTED="${DETECTED}Found: requirements.txt (Python)\n"
    [[ -f "pyproject.toml" ]] && DETECTED="${DETECTED}Found: pyproject.toml (Python)\n"
    [[ -f "pubspec.yaml" ]] && DETECTED="${DETECTED}Found: pubspec.yaml (Flutter/Dart)\n"
    [[ -f "Cargo.toml" ]] && DETECTED="${DETECTED}Found: Cargo.toml (Rust)\n"
    [[ -f "go.mod" ]] && DETECTED="${DETECTED}Found: go.mod (Go)\n"
    [[ -f "CLAUDE.md" ]] && DETECTED="${DETECTED}Found: CLAUDE.md (existing project rules)\n"
    [[ -f ".env.example" ]] && DETECTED="${DETECTED}Found: .env.example (needs .env setup)\n"
    [[ -d "node_modules" ]] || [[ -f "package.json" ]] && [[ ! -d "node_modules" ]] && DETECTED="${DETECTED}Note: node_modules missing - needs npm install\n"
    [[ -d "vendor" ]] || [[ -f "composer.json" ]] && [[ ! -d "vendor" ]] && DETECTED="${DETECTED}Note: vendor missing - needs composer install\n"

    # For existing projects, include source file list
    EXISTING_CODE_INFO=""
    if [[ "$EXISTING_PROJECT" == "true" ]]; then
        EXISTING_CODE_INFO="
## EXISTING SOURCE FILES (explore these to understand what's built):
$SRC_FILES

This is an EXISTING project. You MUST:
1. Explore and understand the existing codebase structure
2. Read key files to understand what's already implemented
3. Document existing functionality in CONTEXT.md
4. Create tasks that BUILD ON existing code, not duplicate it
"
    fi

    INIT_PROMPT=$(cat "${SCRIPT_DIR}/resources/prompt_init.md")

    IDEA_CONTENT=$(cat "$IDEA_FILE")

    # Read CLAUDE.md if exists
    CLAUDE_MD=""
    if [[ -f "CLAUDE.md" ]]; then
        CLAUDE_MD="

## Existing CLAUDE.md (project rules to respect):
$(cat CLAUDE.md)
"
    fi

    run_claude "# IDEA FILE CONTENT:

$IDEA_CONTENT

---

## DETECTED ENVIRONMENT:
$DETECTED
$EXISTING_CODE_INFO
$CLAUDE_MD
---

$INIT_PROMPT" "INIT"

    # Verify files were created
    if [[ -f "$CONTEXT_FILE" ]] && [[ -f "$TASK_FILE" ]]; then
        echo -e "${GREEN}Project initialized!${NC}"
        echo -e "  - $CONTEXT_FILE"
        echo -e "  - $TASK_FILE"
        [[ -d "$SPECS_DIR" ]] && echo -e "  - $SPECS_DIR/"

        # Init git repo if git available and not already in a repo
        if command -v git &> /dev/null; then
            if ! git rev-parse --git-dir &> /dev/null 2>&1; then
                git init -q && \
                git add -A && \
                git commit -q -m "Initial project setup by Bjarne" && \
                echo -e "  - git repo initialized" || true
            fi
        fi

        # Generate Docker config if --safe flag was used
        if [[ "$INIT_SAFE_MODE" == true ]]; then
            echo -e "${CYAN}Generating Docker configuration for safe mode...${NC}"
            generate_dockerfile

            # Add .bjarne to .gitignore if not already there
            if [[ -f ".gitignore" ]]; then
                if ! grep -q "^\.bjarne/" ".gitignore" 2>/dev/null; then
                    echo ".bjarne/" >> ".gitignore"
                fi
            else
                echo ".bjarne/" > ".gitignore"
            fi
            echo -e "  - Added .bjarne/ to .gitignore"

            echo ""
            echo -e "${GREEN}Safe mode enabled!${NC}"
            echo -e "Container will only have access to this project directory."
        fi

        echo ""
        echo -e "${CYAN}Run 'bjarne' to start development${NC}"
    else
        echo -e "${RED}Initialization incomplete - check output above${NC}"
    fi

    exit 0
fi

#==============================================================================
# REBUILD COMMAND - Force rebuild Docker image
#==============================================================================
if [[ "$1" == "--rebuild" ]]; then
    detect_safe_mode

    if [[ "$SAFE_MODE" != true ]]; then
        echo -e "${RED}Error: Not a safe mode project (no $DOCKERFILE found)${NC}"
        echo -e "Run 'bjarne init --safe <idea.md>' to enable safe mode"
        exit 1
    fi

    echo -e "${CYAN}Rebuilding Docker image...${NC}"
    build_docker_image "true"
    exit 0
fi

#==============================================================================
# REFRESH COMMAND - Add tasks from freeform notes
#==============================================================================
if [[ "$1" == "refresh" ]]; then
    NOTES_FILE="$2"

    if [[ -z "$NOTES_FILE" ]]; then
        echo -e "${RED}Usage: bjarne refresh <notes.md>${NC}"
        exit 1
    fi

    if [[ ! -f "$NOTES_FILE" ]]; then
        echo -e "${RED}Error: $NOTES_FILE not found${NC}"
        exit 1
    fi

    if [[ ! -f "$CONTEXT_FILE" ]]; then
        echo -e "${RED}Error: $CONTEXT_FILE not found - run 'bjarne init' first${NC}"
        exit 1
    fi

    if [[ ! -f "$TASK_FILE" ]]; then
        echo -e "${RED}Error: $TASK_FILE not found - run 'bjarne init' first${NC}"
        exit 1
    fi

    echo -e "${CYAN}Bjarne refreshing project from: $NOTES_FILE${NC}"

    REFRESH_PROMPT=$(cat "${SCRIPT_DIR}/resources/prompt_refresh.md")

    NOTES_CONTENT=$(cat "$NOTES_FILE")
    CONTEXT_CONTENT=$(cat "$CONTEXT_FILE")
    TASKS_CONTENT=$(cat "$TASK_FILE")

    # Read CLAUDE.md if exists
    CLAUDE_MD=""
    if [[ -f "CLAUDE.md" ]]; then
        CLAUDE_MD="
## Project Rules (from CLAUDE.md):
$(cat CLAUDE.md)
"
    fi

    run_claude "# USER'S NOTES:

$NOTES_CONTENT

---

## CURRENT CONTEXT.md:
$CONTEXT_CONTENT

---

## CURRENT TASKS.md:
$TASKS_CONTENT

$CLAUDE_MD
---

$REFRESH_PROMPT" "REFRESH"

    # Show result
    NEW_TASKS=$(grep -c '^\s*- \[ \]' "$TASK_FILE" 2>/dev/null || echo "0")
    echo -e "${GREEN}Project refreshed!${NC}"
    echo -e "  - $NEW_TASKS pending tasks in $TASK_FILE"
    echo ""
    echo -e "${CYAN}Run 'bjarne' to work through the new tasks${NC}"

    exit 0
fi

#==============================================================================
# TASK COMMAND - Isolated single-task mode
#==============================================================================
if [[ "$1" == "task" ]]; then
    shift  # Remove "task" from args

    # Parse task command arguments
    TASK_SAFE_MODE=false
    TASK_DESCRIPTION=""
    TASK_NO_PR=false
    TASK_NO_WORKTREE=false
    TASK_MAX_ITERATIONS=25

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --safe)
                TASK_SAFE_MODE=true
                shift
                ;;
            --no-pr)
                TASK_NO_PR=true
                shift
                ;;
            --no-worktree)
                TASK_NO_WORKTREE=true
                shift
                ;;
            -n)
                TASK_MAX_ITERATIONS="$2"
                shift 2
                ;;
            *)
                # Assume it's the task description (or file path)
                TASK_DESCRIPTION="$1"
                shift
                ;;
        esac
    done

    # Auto-detect: if description is an existing file, read it
    if [[ -n "$TASK_DESCRIPTION" ]] && [[ -f "$TASK_DESCRIPTION" ]]; then
        TASK_DESCRIPTION=$(cat "$TASK_DESCRIPTION")
    fi

    if [[ -z "$TASK_DESCRIPTION" ]]; then
        echo -e "${RED}Usage: bjarne task [--safe] [--no-pr] [--no-worktree] [-n iterations] <description or file.md>${NC}"
        echo ""
        echo "Examples:"
        echo "  bjarne task \"Fix the login button not responding\""
        echo "  bjarne task bugfix.md                      # reads file as task"
        echo "  bjarne task --safe \"Add payment integration\""
        echo "  bjarne task --no-worktree \"Quick fix\"     # work in current checkout (affects other sessions)"
        exit 1
    fi

    # Detect git and gh availability
    HAS_GIT=$(detect_git)
    HAS_GH=$(detect_gh)

    # Generate task ID and paths (use absolute paths to survive worktree cd)
    TASK_ID=$(generate_task_id "$TASK_DESCRIPTION")
    TASK_DIR="$BJARNE_PROJECT_ROOT/.bjarne/tasks/$TASK_ID"
    TASK_LOG_DIR="$TASK_DIR/logs"
    TASK_LOG_FILE="$TASK_LOG_DIR/task.log"
    TASK_SUBTASKS="$TASK_DIR/SUBTASKS.md"
    TASK_STATE_FILE="$TASK_DIR/.task"
    TASK_SUMMARY_FILE="$TASK_DIR/summary.md"
    TASK_ORIGINAL_FILE="$TASK_DIR/TASK.md"

    # Create task directory structure
    mkdir -p "$TASK_LOG_DIR"
    echo "$TASK_DESCRIPTION" > "$TASK_ORIGINAL_FILE"

    echo -e "${CYAN}Bjarne task mode${NC}"
    echo -e "  Task ID: $TASK_ID"
    echo -e "  Task dir: $TASK_DIR"
    echo -e "  Git available: $([ \"$HAS_GIT\" == \"1\" ] && echo \"yes\" || echo \"no\")"
    echo -e "  GitHub CLI: $([ \"$HAS_GH\" == \"1\" ] && echo \"yes\" || echo \"no\")"

    # Task-specific log function
    task_log() {
        local level="$1"
        local msg="$2"
        local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        echo "[$timestamp] [$level] $msg" >> "$TASK_LOG_FILE"
    }

    task_log "INFO" "=== Task session started ==="
    task_log "INFO" "Task: $TASK_DESCRIPTION"
    task_log "INFO" "Task ID: $TASK_ID"

    # Track original branch if git available
    ORIGINAL_BRANCH=""
    ORIGINAL_DIR=$(pwd)
    WORKTREE_PATH=""
    WORKTREE_BRANCH=""

    if [[ "$HAS_GIT" == "1" ]]; then
        ORIGINAL_BRANCH=$(git rev-parse --abbrev-ref HEAD)
        task_log "INFO" "Starting branch: $ORIGINAL_BRANCH"

        # Create isolated worktree unless --no-worktree flag is set
        if [[ "$TASK_NO_WORKTREE" != true ]]; then
            # Generate branch name from task description using Claude (with fallback)
            branch_slug=""
            if command -v claude &>/dev/null; then
                branch_slug=$(echo "$TASK_DESCRIPTION" | head -100 | claude -p "Generate a concise git branch name for this task. Rules: max 40 chars, lowercase, hyphens only, no leading/trailing hyphens, descriptive of the work. Output ONLY the branch name, nothing else." 2>/dev/null | tr -d '[:space:]' | head -c 40)
            fi
            # Fallback to simple slug if Claude fails or unavailable
            if [[ -z "$branch_slug" ]]; then
                first_line=$(echo "$TASK_DESCRIPTION" | grep -v '^#' | grep -v '^>' | grep -v '^$' | head -1)
                branch_slug=$(echo "$first_line" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-//' | sed 's/-$//' | cut -c1-40)
            fi
            WORKTREE_BRANCH="feature/${branch_slug}"
            WORKTREE_PATH="/tmp/bjarne-worktree-$TASK_ID"

            echo -e "${CYAN}Creating isolated worktree...${NC}"
            task_log "INFO" "Creating worktree at $WORKTREE_PATH on branch $WORKTREE_BRANCH"

            # Create worktree with new branch
            if ! git worktree add "$WORKTREE_PATH" -b "$WORKTREE_BRANCH" 2>/dev/null; then
                # Branch might already exist, try without -b
                if ! git worktree add "$WORKTREE_PATH" "$WORKTREE_BRANCH" 2>/dev/null; then
                    echo -e "${RED}Failed to create worktree - falling back to current checkout${NC}"
                    task_log "WARN" "Worktree creation failed, using current checkout"
                    WORKTREE_PATH=""
                    WORKTREE_BRANCH=""
                fi
            fi

            if [[ -n "$WORKTREE_PATH" ]] && [[ -d "$WORKTREE_PATH" ]]; then
                echo -e "${GREEN}Working in isolated worktree: $WORKTREE_PATH${NC}"
                echo -e "${GREEN}Branch: $WORKTREE_BRANCH${NC}"
                task_log "INFO" "Worktree created successfully"

                # Change to worktree directory
                cd "$WORKTREE_PATH"

                # Update task directory paths to be absolute (so they work from worktree)
                TASK_DIR="$ORIGINAL_DIR/.bjarne/tasks/$TASK_ID"
                TASK_LOG_DIR="$TASK_DIR/logs"
                TASK_LOG_FILE="$TASK_LOG_DIR/task.log"
                TASK_SUBTASKS="$TASK_DIR/SUBTASKS.md"
                TASK_STATE_FILE="$TASK_DIR/.task"
                TASK_SUMMARY_FILE="$TASK_DIR/summary.md"
                TASK_ORIGINAL_FILE="$TASK_DIR/TASK.md"
            fi
        fi
    fi

    # Cleanup function for worktree
    cleanup_worktree() {
        if [[ -n "$WORKTREE_PATH" ]] && [[ -d "$WORKTREE_PATH" ]]; then
            task_log "INFO" "Cleaning up worktree at $WORKTREE_PATH"
            cd "$ORIGINAL_DIR"
            git worktree remove "$WORKTREE_PATH" --force 2>/dev/null || true
        fi
    }

    # Trap to cleanup on exit/interrupt
    trap cleanup_worktree EXIT

    # Handle safe mode for task
    if [[ "$TASK_SAFE_MODE" == true ]]; then
        if [[ ! -f "$DOCKERFILE" ]]; then
            echo -e "${CYAN}Generating Docker configuration for safe mode...${NC}"
            generate_dockerfile
        fi
        SAFE_MODE=true
        PROJECT_NAME=$(basename "$(pwd)" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g')
        IMAGE_NAME="bjarne-${PROJECT_NAME}"
        build_docker_image "false"
    fi

    echo ""

    # Read project context if available (read-only)
    PROJECT_CONTEXT=""
    if [[ -f "$CONTEXT_FILE" ]]; then
        PROJECT_CONTEXT="## PROJECT CONTEXT (from CONTEXT.md):
$(cat "$CONTEXT_FILE")

"
    fi

    # Read specs if available (read-only)
    SPECS_CONTENT=""
    if [[ -d "$SPECS_DIR" ]]; then
        SPECS_FILES=$(find "$SPECS_DIR" -name "*.md" 2>/dev/null)
        if [[ -n "$SPECS_FILES" ]]; then
            SPECS_CONTENT="## SPECIFICATIONS (from specs/):
$(cat $SPECS_DIR/*.md 2>/dev/null)

"
        fi
    fi

    # Read CLAUDE.md if exists
    CLAUDE_MD_CONTENT=""
    if [[ -f "CLAUDE.md" ]]; then
        CLAUDE_MD_CONTENT="## Project Rules (from CLAUDE.md):
$(cat CLAUDE.md)

"
    fi

    #--------------------------------------------------------------------------
    # DECOMPOSE PHASE - Break task into subtasks
    #--------------------------------------------------------------------------
    echo -e "${BLUE}[DECOMPOSE]${NC} Breaking down task..."
    task_log "INFO" "[DECOMPOSE] Starting..."

    # Build git workflow instructions based on worktree status
    if [[ -n "$WORKTREE_PATH" ]]; then
        GIT_WORKFLOW_INSTRUCTIONS="## Git Workflow
**You are working in an ISOLATED GIT WORKTREE on branch: $WORKTREE_BRANCH**
- Do NOT create a branch subtask - you're already on the feature branch
- Do NOT run git checkout or git switch - stay on current branch
- Just commit your changes during EXECUTE phase
- PR creation happens at the end (handled by bjarne)
"
        GIT_EXAMPLE="- [ ] Add onClick handler to login button â†’ Button calls handleLogin function when clicked"
    else
        GIT_WORKFLOW_INSTRUCTIONS="## Git Workflow (if git available)
1. **First subtask should create a feature branch** (unless task specifies otherwise)
   - Use branch name from task description if provided
   - Otherwise use a descriptive name like \`feature/short-description\` or \`fix/short-description\`
2. Commits happen during EXECUTE phase
3. PR creation happens at the end (handled by bjarne)

If the task description includes specific git instructions (branch name, workflow), follow those.
"
        GIT_EXAMPLE="- [ ] Create feature branch \`feature/login-fix\` â†’ Branch exists and is checked out
- [ ] Add onClick handler to login button â†’ Button calls handleLogin function when clicked"
    fi

    DECOMPOSE_PROMPT_BASE=$(cat "${SCRIPT_DIR}/resources/prompt_decompose_task.md")
    DECOMPOSE_FULL_PROMPT="# TASK TO DECOMPOSE:
$TASK_DESCRIPTION

---

$PROJECT_CONTEXT$SPECS_CONTENT$CLAUDE_MD_CONTENT
$GIT_WORKFLOW_INSTRUCTIONS

## Examples
$GIT_EXAMPLE
- [ ] Test login flow â†’ Clicking login button redirects to /dashboard

---

Write subtasks to: $TASK_SUBTASKS

$DECOMPOSE_PROMPT_BASE"

    if ! run_claude "$DECOMPOSE_FULL_PROMPT" "DECOMPOSE"; then
        echo -e "${RED}Decompose phase failed - aborting${NC}"
        task_log "ERROR" "[DECOMPOSE] Failed - aborting"
        # EXIT trap handles worktree cleanup
        exit 1
    fi

    # Verify SUBTASKS.md was created
    if [[ ! -f "$TASK_SUBTASKS" ]]; then
        echo -e "${RED}Error: SUBTASKS.md not created${NC}"
        task_log "ERROR" "[DECOMPOSE] No SUBTASKS.md created"
        # EXIT trap handles worktree cleanup
        exit 1
    fi

    SUBTASK_COUNT=$(grep -c '^\s*- \[ \]' "$TASK_SUBTASKS" 2>/dev/null || echo "0")
    echo -e "${GREEN}Created $SUBTASK_COUNT subtasks${NC}"
    task_log "INFO" "[DECOMPOSE] Created $SUBTASK_COUNT subtasks"
    echo ""

    #--------------------------------------------------------------------------
    # TASK LOOP - Run until all subtasks complete
    # Uses main prompts with task-mode context injection
    #--------------------------------------------------------------------------

    # Build worktree context if in a worktree
    WORKTREE_CONTEXT=""
    if [[ -n "$WORKTREE_PATH" ]]; then
        WORKTREE_CONTEXT="
**GIT WORKTREE ISOLATION:**
- You are working in an ISOLATED worktree at: $WORKTREE_PATH
- Current branch: $WORKTREE_BRANCH
- Do NOT run \`git checkout\` or \`git switch\` - stay on current branch
- Just make commits - bjarne handles branch management
"
    fi

    # Build task mode context header (injected before each prompt)
    TASK_MODE_HEADER="## TASK MODE - Isolated Fix
$WORKTREE_CONTEXT
**File Mappings (read these instead of defaults):**
- TASKS.md â†’ $TASK_SUBTASKS
- .task â†’ $TASK_STATE_FILE

**Task Mode Rules:**
- You are fixing a specific thing in an EXISTING project
- Do NOT delete any project source files - only modify what's needed
- Do NOT create new test infrastructure if none exists
- If tests exist and this change naturally fits, add/update tests
- If no tests exist, outcome verification (grep, curl, file check) is sufficient

**IMPORTANT - Batch Related Tasks:**
Instead of picking only the FIRST unchecked task, you should:
1. Look at ALL unchecked tasks in the subtasks file
2. Identify a logical GROUP of related/coupled tasks (e.g., all methods in one class, all changes to one file, all tightly coupled changes)
3. Plan and execute them TOGETHER in one iteration
4. This reduces redundant exploration and keeps related changes atomic

Write to .task file with format:
\`\`\`
TASKS: [list the related tasks you're tackling together]
EXPECTED_OUTCOMES:
- [outcome for task 1]
- [outcome for task 2]
...rest of plan format...
\`\`\`

**REVIEW phase**: Verify ALL outcomes for the batched tasks, review ALL code changes together.
**FIX phase**: Fix issues across ALL changes from the batch.
**When done**: Mark ALL completed tasks with [x] in the subtasks file.

"

    echo -e "${CYAN}Starting task loop - max $TASK_MAX_ITERATIONS iterations${NC}"
    echo ""

    for i in $(seq 1 $TASK_MAX_ITERATIONS); do
        # Check for remaining subtasks
        if ! grep -q '^\s*- \[ \]' "$TASK_SUBTASKS"; then
            echo -e "${GREEN}All subtasks complete!${NC}"
            task_log "INFO" "All subtasks complete"
            break
        fi

        REMAINING=$(grep -c '^\s*- \[ \]' "$TASK_SUBTASKS") || REMAINING=0
        echo -e "${YELLOW}=== Task iteration $i/$TASK_MAX_ITERATIONS ($REMAINING subtasks remaining) ===${NC}"
        task_log "INFO" "=== Iteration $i/$TASK_MAX_ITERATIONS ($REMAINING remaining) ==="

        # Build context for this iteration (task mode header + project context)
        ITER_CONTEXT="$TASK_MODE_HEADER$PROJECT_CONTEXT$SPECS_CONTENT$CLAUDE_MD_CONTENT"

        # PLAN (uses main PLAN_PROMPT with task context)
        echo -e "${BLUE}[1/4 PLAN]${NC} Analyzing subtask..."
        task_log "INFO" "[PLAN] Starting..."
        if ! run_claude "$ITER_CONTEXT

$PLAN_PROMPT" "TASK_PLAN"; then
            echo -e "${RED}Plan phase failed - aborting${NC}"
            task_log "ERROR" "[PLAN] Failed - aborting"
            break
        fi

        if [[ ! -f "$TASK_STATE_FILE" ]]; then
            echo -e "${RED}Plan failed - no .task file created${NC}"
            task_log "ERROR" "[PLAN] No .task file created"
            continue
        fi

        # Log which tasks are being worked on
        CURRENT_TASKS=$(grep -E '^TASK:|^TASKS:' "$TASK_STATE_FILE" 2>/dev/null | head -3)
        task_log "INFO" "[PLAN] Working on: $CURRENT_TASKS"

        # EXECUTE (uses main EXECUTE_PROMPT with task context)
        echo -e "${BLUE}[2/4 EXECUTE]${NC} Implementing..."
        task_log "INFO" "[EXECUTE] Starting..."
        if ! run_claude "$ITER_CONTEXT

$EXECUTE_PROMPT" "TASK_EXECUTE"; then
            echo -e "${RED}Execute phase failed - aborting${NC}"
            task_log "ERROR" "[EXECUTE] Failed - aborting"
            break
        fi
        task_log "INFO" "[EXECUTE] Complete"

        # REVIEW (uses main REVIEW_PROMPT with task context)
        echo -e "${BLUE}[3/4 REVIEW]${NC} Reviewing..."
        task_log "INFO" "[REVIEW] Starting..."
        if ! run_claude "$ITER_CONTEXT

$REVIEW_PROMPT" "TASK_REVIEW"; then
            echo -e "${RED}Review phase failed - aborting${NC}"
            task_log "ERROR" "[REVIEW] Failed - aborting"
            break
        fi
        task_log "INFO" "[REVIEW] Complete"

        # FIX (uses main FIX_PROMPT with task context)
        echo -e "${BLUE}[4/4 FIX]${NC} Fixing..."
        task_log "INFO" "[FIX] Starting..."
        if ! run_claude "$ITER_CONTEXT

$FIX_PROMPT" "TASK_FIX"; then
            echo -e "${RED}Fix phase failed - aborting${NC}"
            task_log "ERROR" "[FIX] Failed - aborting"
            break
        fi
        task_log "INFO" "[FIX] Complete"

        # Log completed count
        COMPLETED_NOW=$(grep -c '^\s*- \[x\]' "$TASK_SUBTASKS" 2>/dev/null) || COMPLETED_NOW=0
        task_log "INFO" "Iteration $i complete - $COMPLETED_NOW subtasks done so far"

        sleep 2
    done

    #--------------------------------------------------------------------------
    # FINALIZE - Push, create PR, generate summary (Claude handles git workflow)
    #--------------------------------------------------------------------------
    echo ""
    echo -e "${CYAN}[FINALIZE]${NC} Wrapping up task..."
    task_log "INFO" "[FINALIZE] Starting..."

    # Build finalize prompt - different based on worktree mode
    if [[ -n "$WORKTREE_PATH" ]]; then
        FINALIZE_PROMPT=$(get_finalize_prompt)
    else
        FINALIZE_PROMPT=$(cat "${SCRIPT_DIR}/resources/prompt_finalize.md")
    fi

    # Add no-pr constraint if flag set
    if [[ "$TASK_NO_PR" == true ]]; then
        FINALIZE_PROMPT+="
- Do NOT create a pull request (--no-pr flag was set)"
    fi

    # Add context about original branch
    FINALIZE_PROMPT+="
- Original branch was: $ORIGINAL_BRANCH
- Subtasks file: $TASK_SUBTASKS

## Subtasks Status
$(cat "$TASK_SUBTASKS" 2>/dev/null || echo "No subtasks file found")
"

    # Run finalize phase
    if ! run_claude "$FINALIZE_PROMPT" "FINALIZE"; then
        echo -e "${YELLOW}Finalize phase had issues - check output above${NC}"
        task_log "WARN" "[FINALIZE] Had issues"
    else
        task_log "INFO" "[FINALIZE] Complete"
    fi

    # Return to original branch (safety fallback in case Claude didn't)
    # Skip if in worktree - the EXIT trap handles cleanup
    if [[ "$HAS_GIT" == "1" ]] && [[ -z "$WORKTREE_PATH" ]]; then
        CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
        if [[ "$CURRENT_BRANCH" != "$ORIGINAL_BRANCH" ]]; then
            git checkout "$ORIGINAL_BRANCH" 2>/dev/null
        fi
    fi

    # Log final stats
    FINAL_COMPLETED=$(grep -c '^\s*- \[x\]' "$TASK_SUBTASKS" 2>/dev/null) || FINAL_COMPLETED=0
    FINAL_REMAINING=$(grep -c '^\s*- \[ \]' "$TASK_SUBTASKS" 2>/dev/null) || FINAL_REMAINING=0
    task_log "INFO" "=== TASK FINISHED: $FINAL_COMPLETED completed, $FINAL_REMAINING remaining ==="

    # Output completion
    echo ""
    echo -e "${GREEN}========================================${NC}"
    echo -e "${GREEN}TASK COMPLETE${NC}"
    echo -e "${GREEN}========================================${NC}"

    # Cleanup task state directory
    echo -e "\n${CYAN}Cleaning up task state...${NC}"
    rm -rf "$TASK_DIR"
    echo -e "${GREEN}Done${NC}"
    exit 0
fi

# Only execute when run directly, not when sourced
if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
    echo -e "${RED}Error: bjarne script should be run directly, not sourced${NC}"
    exit 1
fi

#==============================================================================
# MAIN LOOP - PLAN â†’ EXECUTE â†’ REVIEW â†’ FIX
#==============================================================================

# Parse main loop arguments
MAX_ITERATIONS=25
BATCH_MODE=false
BATCH_SIZE=5

while [[ $# -gt 0 ]]; do
    case "$1" in
        --batch=*)
            # --batch=N syntax: batch mode with custom size
            BATCH_MODE=true
            BATCH_SIZE="${1#--batch=}"
            shift
            ;;
        --batch)
            # --batch alone: batch mode with default size
            BATCH_MODE=true
            shift
            ;;
        -b=*)
            # -b=N syntax: batch mode with custom size
            BATCH_MODE=true
            BATCH_SIZE="${1#-b=}"
            shift
            ;;
        -b[0-9]*)
            # -bN syntax (no space): batch mode with custom size
            BATCH_MODE=true
            BATCH_SIZE="${1#-b}"
            shift
            ;;
        -b)
            # -b alone: batch mode with default size
            BATCH_MODE=true
            shift
            ;;
        [0-9]*)
            MAX_ITERATIONS="$1"
            shift
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}"
            echo "Usage: bjarne [options] [iterations]"
            echo "Options:"
            echo "  --batch       Enable batch mode (up to 5 related tasks)"
            echo "  --batch=N     Enable batch mode with custom size"
            echo "  -b, -bN       Short form of --batch, --batch=N"
            exit 1
            ;;
    esac
done

# Check required files
if [[ ! -f "$TASK_FILE" ]]; then
    echo -e "${RED}Error: $TASK_FILE not found${NC}"
    echo -e "Run 'bjarne init <idea.md>' first"
    exit 1
fi

if [[ ! -f "$CONTEXT_FILE" ]]; then
    echo -e "${YELLOW}Warning: $CONTEXT_FILE not found${NC}"
fi

# Main mode testing guidance (injected into context)
MAIN_MODE_HEADER="## DEVELOPMENT MODE - Testing Requirements

**Testing is CRITICAL for the feedback loop:**
- If no tests exist yet â†’ flag as ðŸŸ¡ ISSUE: \"No tests - add test for this feature\"
- If tests exist but don't cover new code â†’ flag as ðŸŸ¡ ISSUE: \"Add test coverage\"
- Tests let you VERIFY the implementation works - without them you're blind
- A feature without tests is not truly complete

"

# Load context fresh each iteration
load_context() {
    CONTEXT="$MAIN_MODE_HEADER"
    if [[ -f "$CONTEXT_FILE" ]]; then
        CONTEXT+=$(cat "$CONTEXT_FILE")
    fi
    # Also include CLAUDE.md if exists (project rules)
    if [[ -f "CLAUDE.md" ]]; then
        CONTEXT="$CONTEXT

## Project Rules (from CLAUDE.md):
$(cat CLAUDE.md)"
    fi
}

# Detect and setup safe mode if applicable
detect_safe_mode
if [[ "$SAFE_MODE" == true ]]; then
    echo -e "${CYAN}Safe mode detected (.bjarne/Dockerfile found)${NC}"
    build_docker_image "false"
    echo ""
fi

# Log session start
log "INFO" "=== Bjarne session started ==="
log "INFO" "Max iterations: $MAX_ITERATIONS, Safe mode: $SAFE_MODE, Batch mode: $BATCH_MODE (size: $BATCH_SIZE)"
log "INFO" "Working directory: $(pwd)"

echo -e "${CYAN}Bjarne starting - max $MAX_ITERATIONS iterations${NC}"
if [[ "$BATCH_MODE" == true ]]; then
    echo -e "${CYAN}Batch mode: up to $BATCH_SIZE related tasks per iteration${NC}"
fi
echo -e "${CYAN}Loop: PLAN â†’ EXECUTE â†’ REVIEW â†’ FIX${NC}"
echo -e "${CYAN}Logs: $LOG_FILE${NC}"
echo ""

for i in $(seq 1 $MAX_ITERATIONS); do
    # Load context fresh each iteration
    load_context

    # Check for remaining tasks
    if ! grep -q '^\s*- \[ \]' "$TASK_FILE"; then
        echo -e "${GREEN}All tasks complete!${NC}"
        rm -f "$TASK_STATE"
        exit 0
    fi

    REMAINING=$(grep -c '^\s*- \[ \]' "$TASK_FILE" || echo "0")
    echo -e "${YELLOW}=== Iteration $i/$MAX_ITERATIONS ($REMAINING tasks remaining) ===${NC}"

    # Select prompts based on batch mode
    if [[ "$BATCH_MODE" == true ]]; then
        ACTIVE_PLAN_PROMPT=$(get_batch_plan_prompt "$BATCH_SIZE")
        ACTIVE_EXECUTE_PROMPT=$(cat "${SCRIPT_DIR}/resources/prompt_batch_execute.md")
        ACTIVE_REVIEW_PROMPT=$(cat "${SCRIPT_DIR}/resources/prompt_batch_review.md")
        ACTIVE_FIX_PROMPT=$(cat "${SCRIPT_DIR}/resources/prompt_batch_fix.md")
    else
        ACTIVE_PLAN_PROMPT="$PLAN_PROMPT"
        ACTIVE_EXECUTE_PROMPT="$EXECUTE_PROMPT"
        ACTIVE_REVIEW_PROMPT="$REVIEW_PROMPT"
        ACTIVE_FIX_PROMPT="$FIX_PROMPT"
    fi

    # PLAN
    echo -e "${BLUE}[1/4 PLAN]${NC} Analyzing..."
    if ! run_claude "$CONTEXT

$ACTIVE_PLAN_PROMPT" "PLAN"; then
        echo -e "${RED}Plan phase failed after $MAX_RETRIES retries - aborting${NC}"
        exit 1
    fi

    if [[ ! -f "$TASK_STATE" ]]; then
        echo -e "${RED}Plan failed - no .task file${NC}"
        continue
    fi

    # EXECUTE
    echo -e "${BLUE}[2/4 EXECUTE]${NC} Implementing..."
    if ! run_claude "$CONTEXT

$ACTIVE_EXECUTE_PROMPT" "EXECUTE"; then
        echo -e "${RED}Execute phase failed after $MAX_RETRIES retries - aborting${NC}"
        exit 1
    fi

    # REVIEW
    echo -e "${BLUE}[3/4 REVIEW]${NC} Reviewing..."
    if ! run_claude "$CONTEXT

$ACTIVE_REVIEW_PROMPT" "REVIEW"; then
        echo -e "${RED}Review phase failed after $MAX_RETRIES retries - aborting${NC}"
        exit 1
    fi

    # FIX
    echo -e "${BLUE}[4/4 FIX]${NC} Fixing..."
    if ! run_claude "$CONTEXT

$ACTIVE_FIX_PROMPT" "FIX"; then
        echo -e "${RED}Fix phase failed after $MAX_RETRIES retries - aborting${NC}"
        exit 1
    fi

    sleep 2
done

echo -e "${YELLOW}Max iterations reached${NC}"
